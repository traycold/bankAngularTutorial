{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ng-table.min.js","webpack:///webpack/bootstrap e357bfb9357d911d16d7","webpack:///external \"angular\"","webpack:///./src/browser/index.ts","webpack:///./src/core/index.ts","webpack:///./src/browser/ngTable.directive.ts","webpack:///./src/browser/ngTableColumn.ts","webpack:///./src/browser/ngTableColumnsBinding.directive.ts","webpack:///./src/browser/ngTableController.ts","webpack:///./src/browser/ngTableDynamic.directive.ts","webpack:///./src/browser/ngTableFilterConfig.ts","webpack:///./src/browser/ngTableFilterRow.directive.ts","webpack:///./src/browser/ngTableFilterRowController.ts","webpack:///./src/browser/ngTableGroupRow.directive.ts","webpack:///./src/browser/ngTableGroupRowController.ts","webpack:///./src/browser/ngTablePagination.directive.ts","webpack:///./src/browser/ngTableSelectFilterDs.directive.ts","webpack:///./src/browser/ngTableSorterRow.directive.ts","webpack:///./src/browser/ngTableSorterRowController.ts","webpack:///./src/core/ngTableDefaultGetData.ts","webpack:///./src/core/ngTableDefaults.ts","webpack:///./src/core/ngTableEventsChannel.ts","webpack:///./src/core/ngTableParams.ts","webpack:///./src/browser/filterRow.html","webpack:///./src/browser/filters/number.html","webpack:///./src/browser/filters/select-multiple.html","webpack:///./src/browser/filters/select.html","webpack:///./src/browser/filters/text.html","webpack:///./src/browser/groupRow.html","webpack:///./src/browser/header.html","webpack:///./src/browser/pager.html","webpack:///./src/browser/sorterRow.html","webpack:///./index.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","_m","args","slice","fn","a","b","apply","concat","__export","angular","ngTable_directive_1","ngTableColumn_1","ngTableColumnsBinding_directive_1","ngTableController_1","ngTableDynamic_directive_1","ngTableFilterConfig_1","ngTableFilterRow_directive_1","ngTableFilterRowController_1","ngTableGroupRow_directive_1","ngTableGroupRowController_1","ngTablePagination_directive_1","ngTableSelectFilterDs_directive_1","ngTableSorterRow_directive_1","ngTableSorterRowController_1","default","directive","ngTable","ngTableColumn","ngTableColumnsBinding","controller","ngTableController","ngTableDynamic","provider","ngTableFilterConfigProvider","ngTableFilterRow","ngTableFilterRowController","ngTableGroupRow","ngTableGroupRowController","ngTablePagination","ngTableSelectFilterDs","ngTableSorterRow","ngTableSorterRowController","ngTableDefaultGetData_1","ngTableDefaults_1","ngTableParams_1","ngTableEventsChannel_1","ngTableDefaultGetDataProvider","ngTableDefaults","ngTableParamsFactory","ngTableEventsChannel","$q","$parse","restrict","priority","scope","compile","element","dataRow","groupRow","columns","rows","ng1","forEach","find","tr","push","filter","hasClass","item","el","attr","getAttrValue","setAttrValue","parsedAttribute","expr","localValue","context","undefined","assign","$scope","parsedExpr","$parent","titleExpr","id","title","titleAlt","headerTitle","sortable","class","groupable","headerTemplateURL","filterData","show","length","attrs","$columns","buildColumns","setupBindingsToInternalScope","loadFilterData","compileDirectiveTemplates","$inject","buildColumn","column","defaultScope","extendedCol","create","defaults","createDefaults","prop","isFunction","prop1","getterSetter","arguments","isScopeLike","getterFn","extend","$column","createGetterSetter","noop","initialValue","newValue","$new","linkFn","$element","$attrs","setter","$watch","newColumns","shallowClone","link","NgTableParams","$timeout","$compile","$document","onDataReloadStatusChange","newStatus","params","hasErrorState","currentParams","filterOptions","settings","hasFilterChanges","applyFilter","page","reload","filterDelay","delayFilter","setupFilterRowBindingsToInternalScope","showFilter","show_filter","hasVisibleFilterColumn","disableFilter","$filterRow","disabled","setupGroupRowBindingsToInternalScope","$groupRow","showGroup","showGroupGetter","getVisibleColumns","some","array","predicate","found","obj","commonInit","onAfterReloadData","newDatapage","visibleColumns","hasGroup","$groups","visibleColumnCount","$data","publisher","onPagesChanged","newPages","pages","$loading","timer","callback","ms","cancel","newParams","oldParams","templates","header","templateHeader","pagination","templatePagination","addClass","headerTemplate","theadFound","children","e","tagName","prepend","paginationTemplate","after","isPromiseLike","val","then","result","data","isArray","isObject","col","parseNgTableDynamicExpr","indexOf","parts","split","tableParams","Error","tableParamsExpr","tElement","row","showExpr","$watchCollection","newCols","init","resetConfigs","config","defaultConfig","setConfig","customConfig","mergeConfig","aliasUrls","ngTableFilterConfig","getTemplateUrl","filterDef","filterKey","filterName","service","getUrlForAlias","aliasName","defaultBaseUrl","defaultExt","publicConfig","copy","$get","replace","templateUrl","getFilterCellCss","layout","size","keys","width","parseInt","toString","getFilterPlaceholderValue","placeholder","controllerAs","getGroupables","getGroupTitle","groupBy","isSelectedGroup","toggleDetail","setGroup","changeSortDirection","newDirection","$selGroup","group","findGroupColumn","groupKey","isGroupingFunc","groupableCols","groupFns","grouping","existingGroupCol","$selGroupTitle","groupedColumn","groupOptions","isExpanded","pubParams","generatePagesArray","template","append","ngTableSelectFilterDsController","bindDataSource","getSelectListData","hasEmptyOption","unshift","$selectData","isMatch","dataInput","Array","when","sortBy","event","parsedSortable","defaultSort","inverseSort","sorting","sortingParams","ctrlKey","metaKey","parameters","ngTableDefaultGetData","$filter","getFilterFn","filterFn","filterFilterName","getOrderByFn","sortingFilterName","hasFilter","filterKeys","parsedFilter","reduce","key","setPath","filterComparator","applyPaging","pagedData","count","total","applySort","orderBy","orderByFn","getData","options","defaultDataOptions","dataOptions","fData","orderedData","path","ret","lastKey","target","parentPathKeys","$rootScope","addTableParamsEvent","eventName","fnName","charAt","toUpperCase","substring","_a","createEventSubscriptionFn","createPublishEventFn","createEventSelectorFn","eventSelector","isEventSelectorFunc","handler","eventSelectorOrScope","actualEvtSelector","$on","eventArgs","_i","isNullInstance","fnArgs","$broadcast","events","$log","baseParameters","baseSettings","isNumber","isNaN","parseFloat","isFinite","parseGroup","_settings","isGroupingFun","sortDirection","convertSortToOrderBy","createComparableParams","_params","groupSortDirection","hasGlobalSearchFieldChanges","currentVal","previousVal","prevParamsMemento","equals","optimizeFilterDelay","defaultFilterOptions","filterDelayThreshold","defaultSettingsFns","runInterceptorPipeline","fetchedData","interceptors","interceptor","thenFn","response","bind","rejectFn","responseError","reject","self","reason","getDefaultSettingFns","dataset","getGroups","groupFn","groupField","getPath","originalDataOptions","gotData","groups","groupName","$hideRows","finally","ks","errParamsMemento","isCommittedDataset","initialEvents","log","debugMode","debug","filterLayout","defaultGroupOptions","newParameters","parseParamsFromUrl","reverse","len","v","newSettings","isDefined","originalDataset","hasDatasetChanged","fireEvent","publishDatasetChanged","significantFilter","filterValue","direction","isSortBy","field","currentPage","totalItems","pageSize","maxBlocks","maxPage","maxPivotPages","minPage","numPages","Math","ceil","type","number","max","active","current","round","paginationMaxBlocks","paginationMinBlocks","min","isDataReloadRequired","previousFilter","url","asString","collectValue","pairs","encodeURIComponent","isSignificantValue","subkey","pname","pData","oldData","publishAfterReloadData","reloadPages","catch","currentPages","oldPages","publishPagesChanged","counts","sortingIndicator","publishAfterCreated","html","run","put","core_1","browser_1"],"mappings":"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","file":"ng-table.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng-table\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"ng-table\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng-table\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"ng-table\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 33);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar angular = __webpack_require__(0);\nvar ngTable_directive_1 = __webpack_require__(4);\nvar ngTableColumn_1 = __webpack_require__(5);\nvar ngTableColumnsBinding_directive_1 = __webpack_require__(6);\nvar ngTableController_1 = __webpack_require__(7);\nvar ngTableDynamic_directive_1 = __webpack_require__(8);\nvar ngTableFilterConfig_1 = __webpack_require__(9);\nvar ngTableFilterRow_directive_1 = __webpack_require__(10);\nvar ngTableFilterRowController_1 = __webpack_require__(11);\nvar ngTableGroupRow_directive_1 = __webpack_require__(12);\nvar ngTableGroupRowController_1 = __webpack_require__(13);\nvar ngTablePagination_directive_1 = __webpack_require__(14);\nvar ngTableSelectFilterDs_directive_1 = __webpack_require__(15);\nvar ngTableSorterRow_directive_1 = __webpack_require__(16);\nvar ngTableSorterRowController_1 = __webpack_require__(17);\n__webpack_require__(25);\n__webpack_require__(27);\n__webpack_require__(26);\n__webpack_require__(28);\n__webpack_require__(31);\n__webpack_require__(30);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = angular.module('ngTable-browser', [])\n    .directive('ngTable', ngTable_directive_1.ngTable)\n    .factory('ngTableColumn', ngTableColumn_1.ngTableColumn)\n    .directive('ngTableColumnsBinding', ngTableColumnsBinding_directive_1.ngTableColumnsBinding)\n    .controller('ngTableController', ngTableController_1.ngTableController)\n    .directive('ngTableDynamic', ngTableDynamic_directive_1.ngTableDynamic)\n    .provider('ngTableFilterConfig', ngTableFilterConfig_1.ngTableFilterConfigProvider)\n    .directive('ngTableFilterRow', ngTableFilterRow_directive_1.ngTableFilterRow)\n    .controller('ngTableFilterRowController', ngTableFilterRowController_1.ngTableFilterRowController)\n    .directive('ngTableGroupRow', ngTableGroupRow_directive_1.ngTableGroupRow)\n    .controller('ngTableGroupRowController', ngTableGroupRowController_1.ngTableGroupRowController)\n    .directive('ngTablePagination', ngTablePagination_directive_1.ngTablePagination)\n    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs_directive_1.ngTableSelectFilterDs)\n    .directive('ngTableSorterRow', ngTableSorterRow_directive_1.ngTableSorterRow)\n    .controller('ngTableSorterRowController', ngTableSorterRowController_1.ngTableSorterRowController);\n__export(__webpack_require__(18));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar angular = __webpack_require__(0);\nvar ngTableDefaultGetData_1 = __webpack_require__(19);\nvar ngTableDefaults_1 = __webpack_require__(20);\nvar ngTableParams_1 = __webpack_require__(22);\nvar ngTableEventsChannel_1 = __webpack_require__(21);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = angular.module('ngTable-core', [])\n    .provider('ngTableDefaultGetData', ngTableDefaultGetData_1.ngTableDefaultGetDataProvider)\n    .value('ngTableDefaults', ngTableDefaults_1.ngTableDefaults)\n    .factory('NgTableParams', ngTableParams_1.ngTableParamsFactory)\n    .factory('ngTableEventsChannel', ngTableEventsChannel_1.ngTableEventsChannel);\n__export(__webpack_require__(23));\n\n\n/***/ },\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTable.$inject = ['$q', '$parse'];\n/**\n * Directive that instantiates {@link ngTableController ngTableController}.\n * @ngdoc directive\n * @name ngTable\n * @example\n *\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" show-filter=\"true\" class=\"table table-bordered\">\n *  <tr ng-repeat=\"user in $data\">\n *      <td data-title=\"'Name'\" sortable=\"'name'\" filter=\"{ 'name': 'text' }\">\n *          {{user.name}}\n *      </td>\n *      <td data-title=\"'Age'\" sortable=\"'age'\" filter=\"{ 'age': 'text' }\">\n *          {{user.age}}\n *      </td>\n *  </tr>\n * </table>\n * ```\n */\nfunction ngTable($q, $parse) {\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function (element) {\n            var columns = [], i = 0, dataRow, groupRow, rows = [];\n            ng1.forEach(element.find('tr'), function (tr) {\n                rows.push(ng1.element(tr));\n            });\n            dataRow = rows.filter(function (tr) {\n                return !tr.hasClass('ng-table-group');\n            })[0];\n            groupRow = rows.filter(function (tr) {\n                return tr.hasClass('ng-table-group');\n            })[0];\n            if (!dataRow) {\n                return undefined;\n            }\n            ng1.forEach(dataRow.find('td'), function (item) {\n                var el = ng1.element(item);\n                if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                    return;\n                }\n                var getAttrValue = function (attr) {\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                var setAttrValue = function (attr, value) {\n                    if (el.attr('x-data-' + attr)) {\n                        el.attr('x-data-' + attr, value);\n                    }\n                    else if (el.attr('data' + attr)) {\n                        el.attr('data' + attr, value);\n                    }\n                    else {\n                        el.attr(attr, value);\n                    }\n                };\n                var parsedAttribute = function (attr) {\n                    var expr = getAttrValue(attr);\n                    if (!expr) {\n                        return undefined;\n                    }\n                    var localValue;\n                    var getter = function (context) {\n                        if (localValue !== undefined) {\n                            return localValue;\n                        }\n                        return $parse(expr)(context);\n                    };\n                    getter.assign = function ($scope, value) {\n                        var parsedExpr = $parse(expr);\n                        if (parsedExpr.assign) {\n                            // we should be writing back to the parent scope as this is where the expression\n                            // came from\n                            parsedExpr.assign($scope.$parent, value);\n                        }\n                        else {\n                            localValue = value;\n                        }\n                    };\n                    return getter;\n                };\n                var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                if (titleExpr) {\n                    el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                }\n                // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                // a corresponding \"safe\" default\n                columns.push({\n                    id: i++,\n                    title: parsedAttribute('title'),\n                    titleAlt: parsedAttribute('title-alt'),\n                    headerTitle: parsedAttribute('header-title'),\n                    sortable: parsedAttribute('sortable'),\n                    'class': parsedAttribute('header-class'),\n                    filter: parsedAttribute('filter'),\n                    groupable: parsedAttribute('groupable'),\n                    headerTemplateURL: parsedAttribute('header'),\n                    filterData: parsedAttribute('filter-data'),\n                    show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n                });\n                if (groupRow || el.attr(\"ng-if\")) {\n                    // change ng-if to bind to our column definition which we know will be writable\n                    // because this will potentially increase the $watch count, only do so if we already have an\n                    // ng-if or when we definitely need to change visibility of the columns.\n                    // currently only ngTableGroupRow directive needs to change visibility\n                    setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n                }\n            });\n            return function (scope, element, attrs, controller) {\n                scope.$columns = columns = controller.buildColumns(columns);\n                controller.setupBindingsToInternalScope(attrs.ngTable);\n                controller.loadFilterData(columns);\n                controller.compileDirectiveTemplates();\n            };\n        }\n    };\n}\nexports.ngTable = ngTable;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableColumn.$inject = [];\n/**\n * @private\n * Service to construct a $column definition used by {@link ngTable ngTable} directive\n */\nfunction ngTableColumn() {\n    return {\n        buildColumn: buildColumn\n    };\n    //////////////\n    function buildColumn(column, defaultScope, columns) {\n        // note: we're not modifying the original column object. This helps to avoid unintended side affects\n        var extendedCol = Object.create(column);\n        var defaults = createDefaults();\n        for (var prop in defaults) {\n            if (extendedCol[prop] === undefined) {\n                extendedCol[prop] = defaults[prop];\n            }\n            if (!ng1.isFunction(extendedCol[prop])) {\n                // wrap raw field values with \"getter\" functions\n                // - this is to ensure consistency with how ngTable.compile builds columns\n                // - note that the original column object is being \"proxied\"; this is important\n                //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                (function (prop1) {\n                    var getterSetter = function getterSetter() {\n                        if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                            getterSetter.assign(null, arguments[0]);\n                        }\n                        else {\n                            return column[prop1];\n                        }\n                    };\n                    getterSetter.assign = function ($scope, value) {\n                        column[prop1] = value;\n                    };\n                    extendedCol[prop1] = getterSetter;\n                })(prop);\n            }\n            (function (prop1) {\n                // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n                var getterFn = extendedCol[prop1];\n                extendedCol[prop1] = function () {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                        getterFn.assign(null, arguments[0]);\n                    }\n                    else {\n                        var scope = arguments[0] || defaultScope;\n                        var context = Object.create(scope);\n                        ng1.extend(context, {\n                            $column: extendedCol,\n                            $columns: columns\n                        });\n                        return getterFn.call(column, context);\n                    }\n                };\n                if (getterFn.assign) {\n                    extendedCol[prop1].assign = getterFn.assign;\n                }\n            })(prop);\n        }\n        return extendedCol;\n    }\n    function createDefaults() {\n        return {\n            'class': createGetterSetter(''),\n            filter: createGetterSetter(false),\n            groupable: createGetterSetter(false),\n            filterData: ng1.noop,\n            headerTemplateURL: createGetterSetter(false),\n            headerTitle: createGetterSetter(''),\n            sortable: createGetterSetter(false),\n            show: createGetterSetter(true),\n            title: createGetterSetter(''),\n            titleAlt: createGetterSetter('')\n        };\n    }\n    function createGetterSetter(initialValue) {\n        var value = initialValue;\n        var getterSetter = function getterSetter() {\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                getterSetter.assign(null, arguments[0]);\n            }\n            else {\n                return value;\n            }\n        };\n        getterSetter.assign = function ($scope, newValue) {\n            value = newValue;\n        };\n        return getterSetter;\n    }\n    function isScopeLike(object) {\n        return object != null && ng1.isFunction(object.$new);\n    }\n}\nexports.ngTableColumn = ngTableColumn;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableColumnsBinding.$inject = [\"$parse\"];\n/**\n * One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n * expression.\n * This allows the $columns array created for the table to be accessed outside of the html table\n * markup.\n *\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" class=\"table\" ng-table-columns-binding=\"$ctlr.tableColumns\">\n * ```\n */\nfunction ngTableColumnsBinding($parse) {\n    var directive = {\n        restrict: 'A',\n        require: 'ngTable',\n        link: linkFn\n    };\n    return directive;\n    function linkFn($scope, $element, $attrs) {\n        var setter = $parse($attrs.ngTableColumnsBinding).assign;\n        if (setter) {\n            $scope.$watch('$columns', function (newColumns) {\n                var shallowClone = (newColumns || []).slice(0);\n                setter($scope, shallowClone);\n            });\n        }\n    }\n}\nexports.ngTableColumnsBinding = ngTableColumnsBinding;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableController.$inject = [\n    '$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element', '$document', 'ngTableColumn', 'ngTableEventsChannel'\n];\n/**\n * The controller for the {@link ngTable ngTable} and {@link ngTableDynamic ngTableDynamic} directives\n */\nfunction ngTableController($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, $document, ngTableColumn, ngTableEventsChannel) {\n    var isFirstTimeLoad = true;\n    $scope.$filterRow = { disabled: false };\n    $scope.$loading = false;\n    // until such times as the directive uses an isolated scope, we need to ensure that the check for\n    // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n    // field on a $scope higher up in the prototype chain\n    if (!$scope.hasOwnProperty(\"params\")) {\n        $scope.params = new NgTableParams(true);\n    }\n    var delayFilter = (function () {\n        var timer;\n        return function (callback, ms) {\n            $timeout.cancel(timer);\n            timer = $timeout(callback, ms);\n        };\n    })();\n    function onDataReloadStatusChange(newStatus /*, oldStatus*/) {\n        if (!newStatus || $scope.params.hasErrorState()) {\n            return;\n        }\n        var currentParams = $scope.params;\n        var filterOptions = currentParams.settings().filterOptions;\n        if (currentParams.hasFilterChanges()) {\n            var applyFilter = function () {\n                currentParams.page(1);\n                currentParams.reload();\n            };\n            if (filterOptions.filterDelay) {\n                delayFilter(applyFilter, filterOptions.filterDelay);\n            }\n            else {\n                applyFilter();\n            }\n        }\n        else {\n            currentParams.reload();\n        }\n    }\n    // watch for when a new NgTableParams is bound to the scope\n    // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n    // the current data page as a field. Checking this for value equality would be terrible for performance\n    // and potentially cause an error if the items in that array has circular references\n    $scope.$watch('params', function (newParams, oldParams) {\n        if (newParams === oldParams || !newParams) {\n            return;\n        }\n        newParams.reload();\n    }, false);\n    $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n    this.compileDirectiveTemplates = function () {\n        if (!$element.hasClass('ng-table')) {\n            $scope.templates = {\n                header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n                pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n            };\n            $element.addClass('ng-table');\n            var headerTemplate = null;\n            // $element.find('> thead').length === 0 doesn't work on jqlite\n            var theadFound = false;\n            ng1.forEach($element.children(), function (e) {\n                if (e.tagName === 'THEAD') {\n                    theadFound = true;\n                }\n            });\n            if (!theadFound) {\n                headerTemplate = ng1.element('<thead ng-include=\"templates.header\"></thead>', $document);\n                $element.prepend(headerTemplate);\n            }\n            var paginationTemplate = ng1.element('<div ng-table-pagination=\"params\" template-url=\"templates.pagination\"></div>', $document);\n            $element.after(paginationTemplate);\n            if (headerTemplate) {\n                $compile(headerTemplate)($scope);\n            }\n            $compile(paginationTemplate)($scope);\n        }\n    };\n    this.loadFilterData = function ($columns) {\n        ng1.forEach($columns, function ($column) {\n            var result = $column.filterData($scope);\n            if (!result) {\n                delete $column.filterData;\n                return undefined;\n            }\n            if (isPromiseLike(result)) {\n                delete $column.filterData;\n                return result.then(function (data) {\n                    // our deferred can eventually return arrays, functions and objects\n                    if (!ng1.isArray(data) && !ng1.isFunction(data) && !ng1.isObject(data)) {\n                        // if none of the above was found - we just want an empty array\n                        data = [];\n                    }\n                    $column.data = data;\n                });\n            }\n            else {\n                return $column.data = result;\n            }\n        });\n        function isPromiseLike(val) {\n            return val && typeof val === 'object' && typeof val.then === 'function';\n        }\n    };\n    this.buildColumns = function (columns) {\n        var result = [];\n        (columns || []).forEach(function (col) {\n            result.push(ngTableColumn.buildColumn(col, $scope, result));\n        });\n        return result;\n    };\n    this.parseNgTableDynamicExpr = function (attr) {\n        if (!attr || attr.indexOf(\" with \") > -1) {\n            var parts = attr.split(/\\s+with\\s+/);\n            return {\n                tableParams: parts[0],\n                columns: parts[1]\n            };\n        }\n        else {\n            throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n        }\n    };\n    this.setupBindingsToInternalScope = function (tableParamsExpr) {\n        // note: this we're setting up watches to simulate angular's isolated scope bindings\n        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n        // $watch for value equivalence. This is because ngTableParams references the current page of data as\n        // a field and it's important not to watch this\n        $scope.$watch(tableParamsExpr, function (params) {\n            if (params === undefined) {\n                return;\n            }\n            $scope.params = params;\n        }, false);\n        setupFilterRowBindingsToInternalScope();\n        setupGroupRowBindingsToInternalScope();\n    };\n    function setupFilterRowBindingsToInternalScope() {\n        if ($attrs.showFilter) {\n            $scope.$parent.$watch($attrs.showFilter, function (value) {\n                $scope.show_filter = value;\n            });\n        }\n        else {\n            $scope.$watch(hasVisibleFilterColumn, function (value) {\n                $scope.show_filter = value;\n            });\n        }\n        if ($attrs.disableFilter) {\n            $scope.$parent.$watch($attrs.disableFilter, function (value) {\n                $scope.$filterRow.disabled = value;\n            });\n        }\n    }\n    function setupGroupRowBindingsToInternalScope() {\n        $scope.$groupRow = { show: false };\n        if ($attrs.showGroup) {\n            var showGroupGetter = $parse($attrs.showGroup);\n            $scope.$parent.$watch(showGroupGetter, function (value) {\n                $scope.$groupRow.show = value;\n            });\n            if (showGroupGetter.assign) {\n                // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n                $scope.$watch('$groupRow.show', function (value) {\n                    showGroupGetter.assign($scope.$parent, value);\n                });\n            }\n        }\n        else {\n            $scope.$watch('params.hasGroup()', function (newValue) {\n                $scope.$groupRow.show = newValue;\n            });\n        }\n    }\n    function getVisibleColumns() {\n        return ($scope.$columns || []).filter(function (c) {\n            return c.show($scope);\n        });\n    }\n    function hasVisibleFilterColumn() {\n        if (!$scope.$columns)\n            return false;\n        return some($scope.$columns, function ($column) {\n            return $column.show($scope) && !!$column.filter($scope);\n        });\n    }\n    function some(array, predicate) {\n        var found = false;\n        for (var i = 0; i < array.length; i++) {\n            var obj = array[i];\n            if (predicate(obj)) {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    }\n    function commonInit() {\n        ngTableEventsChannel.onAfterReloadData(function (params, newDatapage) {\n            var visibleColumns = getVisibleColumns();\n            if (params.hasGroup()) {\n                $scope.$groups = (newDatapage || []);\n                $scope.$groups.visibleColumnCount = visibleColumns.length;\n            }\n            else {\n                $scope.$data = (newDatapage || []);\n                $scope.$data.visibleColumnCount = visibleColumns.length;\n            }\n        }, $scope, function (publisher) { return $scope.params === publisher; });\n        ngTableEventsChannel.onPagesChanged(function (params, newPages) {\n            $scope.pages = newPages;\n        }, $scope, function (publisher) { return $scope.params === publisher; });\n    }\n    commonInit();\n}\nexports.ngTableController = ngTableController;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableDynamic.$inject = [];\n/**\n * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n * definitions to render\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table-dynamic=\"$ctrl.tableParams with $ctrl.cols\" class=\"table\">\n *  <tr ng-repeat=\"row in $data\">\n *    <td ng-repeat=\"col in $columns\">{{row[col.field]}}</td>\n *  </tr>\n * </table>\n * ```\n */\nfunction ngTableDynamic() {\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function (tElement) {\n            var row;\n            // IE 8 fix :not(.ng-table-group) selector\n            ng1.forEach(tElement.find('tr'), function (tr) {\n                tr = ng1.element(tr);\n                if (!tr.hasClass('ng-table-group') && !row) {\n                    row = tr;\n                }\n            });\n            if (!row) {\n                return undefined;\n            }\n            ng1.forEach(row.find('td'), function (item) {\n                var el = ng1.element(item);\n                var getAttrValue = function (attr) {\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                // this used in responsive table\n                var titleExpr = getAttrValue('title');\n                if (!titleExpr) {\n                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                }\n                var showExpr = el.attr('ng-if');\n                if (!showExpr) {\n                    el.attr('ng-if', '$columns[$index].show(this)');\n                }\n            });\n            return function (scope, element, attrs, controller) {\n                var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n                controller.setupBindingsToInternalScope(expr.tableParams);\n                controller.compileDirectiveTemplates();\n                scope.$watchCollection(expr.columns, function (newCols /*, oldCols*/) {\n                    scope.$columns = controller.buildColumns(newCols);\n                    controller.loadFilterData(scope.$columns);\n                });\n            };\n        }\n    };\n}\nexports.ngTableDynamic = ngTableDynamic;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableFilterConfigProvider.$inject = [];\n/**\n * The angular provider used to configure the behaviour of the `ngTableFilterConfig` service.\n *\n * Implements the {@link IFilterConfigProvider IFilterConfigProvider} interface\n */\nfunction ngTableFilterConfigProvider() {\n    var config;\n    var defaultConfig = {\n        defaultBaseUrl: 'ng-table/filters/',\n        defaultExt: '.html',\n        aliasUrls: {}\n    };\n    this.$get = ngTableFilterConfig;\n    this.resetConfigs = resetConfigs;\n    this.setConfig = setConfig;\n    init();\n    /////////\n    function init() {\n        resetConfigs();\n    }\n    function resetConfigs() {\n        config = defaultConfig;\n    }\n    function setConfig(customConfig) {\n        var mergeConfig = ng1.extend({}, config, customConfig);\n        mergeConfig.aliasUrls = ng1.extend({}, config.aliasUrls, customConfig.aliasUrls);\n        config = mergeConfig;\n    }\n    /////////\n    ngTableFilterConfig.$inject = [];\n    function ngTableFilterConfig() {\n        var publicConfig;\n        var service = {\n            config: publicConfig,\n            getTemplateUrl: getTemplateUrl,\n            getUrlForAlias: getUrlForAlias\n        };\n        Object.defineProperty(service, \"config\", {\n            get: function () {\n                return publicConfig = publicConfig || ng1.copy(config);\n            },\n            enumerable: true\n        });\n        return service;\n        /////////\n        function getTemplateUrl(filterDef, filterKey) {\n            var filterName;\n            if (typeof filterDef !== 'string') {\n                filterName = filterDef.id;\n            }\n            else {\n                filterName = filterDef;\n            }\n            if (filterName.indexOf('/') !== -1) {\n                return filterName;\n            }\n            return service.getUrlForAlias(filterName, filterKey);\n        }\n        function getUrlForAlias(aliasName, filterKey) {\n            return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n        }\n    }\n}\nexports.ngTableFilterConfigProvider = ngTableFilterConfigProvider;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(24);\nngTableFilterRow.$inject = [];\n/**\n * directive that renders the filter header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-filter-row></ng-table-filter-row>\n * ```\n */\nfunction ngTableFilterRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableFilterRowController'\n    };\n    return directive;\n}\nexports.ngTableFilterRow = ngTableFilterRow;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n/**\n * Controller for the {@link ngTableFilterRow ngTableFilterRow} directive\n */\nfunction ngTableFilterRowController($scope, ngTableFilterConfig) {\n    $scope.config = ngTableFilterConfig;\n    $scope.getFilterCellCss = function (filter, layout) {\n        if (layout !== 'horizontal') {\n            return 's12';\n        }\n        var size = Object.keys(filter).length;\n        var width = parseInt((12 / size).toString(), 10);\n        return 's' + width;\n    };\n    $scope.getFilterPlaceholderValue = function (filterDef, filterKey) {\n        if (typeof filterDef === 'string') {\n            return '';\n        }\n        else {\n            return filterDef.placeholder;\n        }\n    };\n}\nexports.ngTableFilterRowController = ngTableFilterRowController;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(29);\nngTableGroupRow.$inject = [];\n/**\n * directive that renders the group header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-group-row></ng-table-group-row>\n * ```\n */\nfunction ngTableGroupRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableGroupRowController',\n        controllerAs: 'dctrl'\n    };\n    return directive;\n}\nexports.ngTableGroupRow = ngTableGroupRow;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableGroupRowController.$inject = ['$scope'];\n/**\n * Controller for the {@link ngTableGroupRow ngTableGroupRow} directive\n */\nfunction ngTableGroupRowController($scope) {\n    var groupFns = [];\n    init();\n    function init() {\n        $scope.getGroupables = getGroupables;\n        $scope.getGroupTitle = getGroupTitle;\n        $scope.getVisibleColumns = getVisibleColumns;\n        $scope.groupBy = groupBy;\n        $scope.isSelectedGroup = isSelectedGroup;\n        $scope.toggleDetail = toggleDetail;\n        $scope.$watch('params.group()', setGroup, true);\n    }\n    function changeSortDirection() {\n        var newDirection;\n        if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n            newDirection = 'desc';\n        }\n        else if ($scope.params.hasGroup($scope.$selGroup, 'desc')) {\n            newDirection = '';\n        }\n        else {\n            newDirection = 'asc';\n        }\n        $scope.params.group($scope.$selGroup, newDirection);\n    }\n    function findGroupColumn(groupKey) {\n        return $scope.$columns.filter(function ($column) {\n            return $column.groupable($scope) === groupKey;\n        })[0];\n    }\n    function getGroupTitle(group) {\n        return isGroupingFunc(group) ? group.title : group.title($scope);\n    }\n    function getGroupables() {\n        var groupableCols = $scope.$columns.filter(function ($column) {\n            return !!$column.groupable($scope);\n        });\n        return groupFns.concat(groupableCols);\n    }\n    function getVisibleColumns() {\n        return $scope.$columns.filter(function ($column) {\n            return $column.show($scope);\n        });\n    }\n    function groupBy(group) {\n        if (isSelectedGroup(group)) {\n            changeSortDirection();\n        }\n        else {\n            if (isGroupingFunc(group)) {\n                $scope.params.group(group);\n            }\n            else {\n                // it's OK, we know that groupable will return a string\n                // this is guaranteed by getGroupables returning only\n                // columns that return (truthy) strings\n                $scope.params.group(group.groupable($scope));\n            }\n        }\n    }\n    function isGroupingFunc(val) {\n        return typeof val === 'function';\n    }\n    function isSelectedGroup(group) {\n        if (isGroupingFunc(group)) {\n            return group === $scope.$selGroup;\n        }\n        else {\n            return group.groupable($scope) === $scope.$selGroup;\n        }\n    }\n    function setGroup(grouping) {\n        var existingGroupCol = findGroupColumn($scope.$selGroup);\n        if (existingGroupCol && existingGroupCol.show.assign) {\n            existingGroupCol.show.assign($scope, true);\n        }\n        if (isGroupingFunc(grouping)) {\n            groupFns = [grouping];\n            $scope.$selGroup = grouping;\n            $scope.$selGroupTitle = grouping.title;\n        }\n        else {\n            // note: currently only one group is implemented\n            var groupKey = Object.keys(grouping || {})[0];\n            var groupedColumn = findGroupColumn(groupKey);\n            if (groupedColumn) {\n                $scope.$selGroupTitle = groupedColumn.title($scope);\n                $scope.$selGroup = groupKey;\n                if (groupedColumn.show.assign) {\n                    groupedColumn.show.assign($scope, false);\n                }\n            }\n        }\n    }\n    function toggleDetail() {\n        $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n        return $scope.params.reload();\n    }\n}\nexports.ngTableGroupRowController = ngTableGroupRowController;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTablePagination.$inject = ['$compile', '$document', 'ngTableEventsChannel'];\n/**\n * Directive that renders the table pagination controls\n * @ngdoc directive\n */\nfunction ngTablePagination($compile, $document, ngTableEventsChannel) {\n    return {\n        restrict: 'A',\n        scope: {\n            'params': '=ngTablePagination',\n            'templateUrl': '='\n        },\n        replace: false,\n        link: function (scope, element /*, attrs*/) {\n            ngTableEventsChannel.onAfterReloadData(function (pubParams) {\n                scope.pages = pubParams.generatePagesArray();\n            }, scope, function (pubParams) {\n                return pubParams === scope.params;\n            });\n            scope.$watch('templateUrl', function (templateUrl) {\n                if (templateUrl === undefined) {\n                    return;\n                }\n                var template = ng1.element('<div ng-include=\"templateUrl\"></div>', $document);\n                element.append(template);\n                $compile(template)(scope);\n            });\n        }\n    };\n}\nexports.ngTablePagination = ngTablePagination;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableSelectFilterDs.$inject = [];\n/**\n * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n *\n * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n * \"deselecting\" an item from a `<select>` tag\n *\n * This directive is is focused on providing a datasource to an `ngOptions` directive\n * @ngdoc directive\n * @private\n */\nfunction ngTableSelectFilterDs() {\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n    var directive = {\n        restrict: 'A',\n        controller: ngTableSelectFilterDsController\n    };\n    return directive;\n}\nexports.ngTableSelectFilterDs = ngTableSelectFilterDs;\nngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\nfunction ngTableSelectFilterDsController($scope, $parse, $attrs, $q) {\n    var $column;\n    init();\n    function init() {\n        $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n        $scope.$watch(function () {\n            return $column && $column.data;\n        }, bindDataSource);\n    }\n    function bindDataSource() {\n        getSelectListData($column).then(function (data) {\n            if (data && !hasEmptyOption(data)) {\n                data.unshift({ id: '', title: '' });\n            }\n            data = data || [];\n            $scope.$selectData = data;\n        });\n    }\n    function hasEmptyOption(data) {\n        var isMatch;\n        for (var i = 0; i < data.length; i++) {\n            var item = data[i];\n            if (item && item.id === '') {\n                isMatch = true;\n                break;\n            }\n        }\n        return isMatch;\n    }\n    function getSelectListData($column) {\n        var dataInput = $column.data;\n        if (dataInput instanceof Array) {\n            return $q.when(dataInput);\n        }\n        else {\n            return $q.when(dataInput && dataInput());\n        }\n    }\n}\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(32);\nngTableSorterRow.$inject = [];\n/**\n * directive that renders the sorting header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-sorter-row></ng-table-sorter-row>\n * ```\n */\nfunction ngTableSorterRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableSorterRowController'\n    };\n    return directive;\n}\nexports.ngTableSorterRow = ngTableSorterRow;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nngTableSorterRowController.$inject = ['$scope'];\n/**\n * Controller for the {@link ngTableSorterRow ngTableSorterRow} directive\n */\nfunction ngTableSorterRowController($scope) {\n    $scope.sortBy = sortBy;\n    ///////////\n    function sortBy($column, event) {\n        var parsedSortable = $column.sortable && $column.sortable();\n        if (!parsedSortable || typeof parsedSortable !== 'string') {\n            return;\n        }\n        else {\n            var defaultSort = $scope.params.settings().defaultSort;\n            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n            var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n            $scope.params.parameters({\n                sorting: sortingParams\n            });\n        }\n    }\n}\nexports.ngTableSorterRowController = ngTableSorterRowController;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\n/**\n * Allows for the configuration of the ngTableDefaultGetData service.\n *\n * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n * `NgTableParams.filter()` to restrict an array of data.\n *\n * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n * `NgTableParams.orderBy()` to sort an array of data.\n *\n * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n * filters respectively\n *\n * @ngdoc provider\n */\nvar ngTableDefaultGetDataProvider = (function () {\n    function ngTableDefaultGetDataProvider() {\n        this.filterFilterName = 'filter';\n        this.sortingFilterName = 'orderBy';\n        var provider = this;\n        this.$get = ngTableDefaultGetData;\n        ngTableDefaultGetData.$inject = ['$filter'];\n        /**\n         * Implementation of the {@link IDefaultGetData IDefaultGetData} interface\n         *\n         * @ngdoc service\n         */\n        function ngTableDefaultGetData($filter) {\n            var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n            getData.applyPaging = applyPaging;\n            getData.getFilterFn = getFilterFn;\n            getData.getOrderByFn = getOrderByFn;\n            return getData;\n            function getFilterFn(params) {\n                var filterOptions = params.settings().filterOptions;\n                if (ng1.isFunction(filterOptions.filterFn)) {\n                    return filterOptions.filterFn;\n                }\n                else {\n                    return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n                }\n            }\n            function getOrderByFn(params) {\n                return $filter(provider.sortingFilterName);\n            }\n            function applyFilter(data, params) {\n                if (!params.hasFilter()) {\n                    return data;\n                }\n                var filter = params.filter(true);\n                var filterKeys = Object.keys(filter);\n                var parsedFilter = filterKeys.reduce(function (result, key) {\n                    result = setPath(result, filter[key], key);\n                    return result;\n                }, {});\n                var filterFn = getFilterFn(params);\n                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n            }\n            function applyPaging(data, params) {\n                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n                params.total(data.length); // set total for recalc pagination\n                return pagedData;\n            }\n            function applySort(data, params) {\n                var orderBy = params.orderBy();\n                var orderByFn = getOrderByFn(params);\n                return orderBy.length ? orderByFn(data, orderBy) : data;\n            }\n            function getData(data, params) {\n                if (data == null) {\n                    return [];\n                }\n                var options = ng1.extend({}, defaultDataOptions, params.settings().dataOptions);\n                var fData = options.applyFilter ? applyFilter(data, params) : data;\n                var orderedData = options.applySort ? applySort(fData, params) : fData;\n                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n            }\n            // Sets the value at any depth in a nested object based on the path\n            // note: adapted from: underscore-contrib#setPath\n            function setPath(obj, value, path) {\n                var keys = path.split('.');\n                var ret = obj;\n                var lastKey = keys[keys.length - 1];\n                var target = ret;\n                var parentPathKeys = keys.slice(0, keys.length - 1);\n                parentPathKeys.forEach(function (key) {\n                    if (!target.hasOwnProperty(key)) {\n                        target[key] = {};\n                    }\n                    target = target[key];\n                });\n                target[lastKey] = value;\n                return ret;\n            }\n        }\n    }\n    return ngTableDefaultGetDataProvider;\n}());\nexports.ngTableDefaultGetDataProvider = ngTableDefaultGetDataProvider;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\n/**\n * Default values for ngTable\n * @ngdoc object\n */\nexports.ngTableDefaults = {\n    params: {},\n    settings: {}\n};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableEventsChannel.$inject = ['$rootScope'];\n/**\n * Implementation of the {@link IEventsChannel IEventsChannel} interface\n * @ngdoc service\n */\nfunction ngTableEventsChannel($rootScope) {\n    var events = {};\n    events = addTableParamsEvent('afterCreated', events);\n    events = addTableParamsEvent('afterReloadData', events);\n    events = addTableParamsEvent('datasetChanged', events);\n    events = addTableParamsEvent('pagesChanged', events);\n    return events;\n    //////////\n    function addTableParamsEvent(eventName, target) {\n        var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n        var event = (_a = {},\n            _a['on' + fnName] = createEventSubscriptionFn(eventName),\n            _a['publish' + fnName] = createPublishEventFn(eventName),\n            _a\n        );\n        return ng1.extend(target, event);\n        var _a;\n    }\n    function createEventSubscriptionFn(eventName) {\n        return function subscription(handler, eventSelectorOrScope, eventSelector) {\n            var actualEvtSelector;\n            var scope = $rootScope;\n            if (isScopeLike(eventSelectorOrScope)) {\n                scope = eventSelectorOrScope;\n                actualEvtSelector = createEventSelectorFn(eventSelector);\n            }\n            else {\n                actualEvtSelector = createEventSelectorFn(eventSelectorOrScope);\n            }\n            return scope.$on('ngTable:' + eventName, function (event, params) {\n                var eventArgs = [];\n                for (var _i = 2; _i < arguments.length; _i++) {\n                    eventArgs[_i - 2] = arguments[_i];\n                }\n                // don't send events published by the internal NgTableParams created by ngTableController\n                if (params.isNullInstance)\n                    return;\n                var fnArgs = [params].concat(eventArgs);\n                if (actualEvtSelector.apply(this, fnArgs)) {\n                    handler.apply(this, fnArgs);\n                }\n            });\n        };\n        function createEventSelectorFn(eventSelector) {\n            if (!eventSelector) {\n                return function (publisher) { return true; };\n            }\n            else if (isEventSelectorFunc(eventSelector)) {\n                return eventSelector;\n            }\n            else {\n                // shorthand for subscriber to only receive events from a specific publisher instance\n                return function (publisher) { return publisher === eventSelector; };\n            }\n        }\n        function isEventSelectorFunc(val) {\n            return typeof val === 'function';\n        }\n        function isScopeLike(val) {\n            return val && typeof val.$new === 'function';\n        }\n    }\n    function createPublishEventFn(eventName) {\n        return function publish() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            $rootScope.$broadcast.apply($rootScope, ['ngTable:' + eventName].concat(args));\n        };\n    }\n}\nexports.ngTableEventsChannel = ngTableEventsChannel;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableParamsFactory.$inject = [\n    '$q', '$log', '$filter', 'ngTableDefaults', 'ngTableDefaultGetData', 'ngTableEventsChannel'\n];\n/**\n * Implmenentation of the {@link INgTableParams INgTableParams} interface\n * @ngdoc service\n */\nfunction ngTableParamsFactory($q, $log, $filter, ngTableDefaults, ngTableDefaultGetData, ngTableEventsChannel) {\n    return NgTableParams;\n    function NgTableParams(baseParameters, baseSettings) {\n        function isNumber(n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        }\n        // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n        // is one of these\n        if (typeof baseParameters === \"boolean\") {\n            this.isNullInstance = true;\n        }\n        var self = this, prevParamsMemento, errParamsMemento, isCommittedDataset = false, initialEvents = [], log = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            if (_settings.debugMode && $log.debug) {\n                $log.debug.apply($log, args);\n            }\n        }, defaultFilterOptions = {\n            filterComparator: undefined,\n            filterDelay: 500,\n            filterDelayThreshold: 10000,\n            filterFilterName: undefined,\n            filterFn: undefined,\n            filterLayout: 'stack' // alternative: 'horizontal'\n        }, defaultGroupOptions = {\n            defaultSort: 'asc',\n            isExpanded: true\n        }, defaultSettingsFns = getDefaultSettingFns();\n        this.data = [];\n        this.parameters = function (newParameters, parseParamsFromUrl) {\n            parseParamsFromUrl = parseParamsFromUrl || false;\n            if (typeof newParameters !== undefined) {\n                for (var key in newParameters) {\n                    var value = newParameters[key];\n                    if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                        var keys = key.split(/\\[(.*)\\]/).reverse();\n                        var lastKey = '';\n                        for (var i = 0, len = keys.length; i < len; i++) {\n                            var name = keys[i];\n                            if (name !== '') {\n                                var v = value;\n                                value = {};\n                                value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                            }\n                        }\n                        if (lastKey === 'sorting') {\n                            _params[lastKey] = {};\n                        }\n                        _params[lastKey] = ng1.extend(_params[lastKey] || {}, value[lastKey]);\n                    }\n                    else {\n                        if (key === 'group') {\n                            _params[key] = parseGroup(newParameters[key]);\n                        }\n                        else {\n                            _params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                        }\n                    }\n                }\n                log('ngTable: set parameters', _params);\n                return this;\n            }\n            return _params;\n        };\n        function parseGroup(group) {\n            var defaultSort = _settings.groupOptions && _settings.groupOptions.defaultSort;\n            if (!group) {\n                return group;\n            }\n            else if (isGroupingFun(group)) {\n                if (group.sortDirection == null) {\n                    group.sortDirection = defaultSort;\n                }\n                return group;\n            }\n            else if (typeof group === 'object') {\n                for (var key in group) {\n                    if (group[key] == null) {\n                        group[key] = defaultSort;\n                    }\n                }\n                return group;\n            }\n            else {\n                return (_a = {},\n                    _a[group] = defaultSort,\n                    _a\n                );\n            }\n            var _a;\n        }\n        /**\n         * @ngdoc method\n         * @name NgTableParams#settings\n         * @description Set new settings for table\n         *\n         * @param {string} newSettings New settings or undefined\n         * @returns {Object} Current settings or `this`\n         */\n        this.settings = function (newSettings) {\n            if (ng1.isDefined(newSettings)) {\n                // todo: don't modify newSettings object: this introduces unexpected side effects;\n                // instead take a copy of newSettings\n                if (newSettings.filterOptions) {\n                    newSettings.filterOptions = ng1.extend({}, _settings.filterOptions, newSettings.filterOptions);\n                }\n                if (newSettings.groupOptions) {\n                    newSettings.groupOptions = ng1.extend({}, _settings.groupOptions, newSettings.groupOptions);\n                }\n                if (ng1.isArray(newSettings.dataset)) {\n                    //auto-set the total from passed in dataset\n                    newSettings.total = newSettings.dataset.length;\n                }\n                var originalDataset = _settings.dataset;\n                _settings = ng1.extend(_settings, newSettings);\n                if (ng1.isArray(newSettings.dataset)) {\n                    optimizeFilterDelay();\n                }\n                // note: using != as want null and undefined to be treated the same\n                var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n                if (hasDatasetChanged) {\n                    if (isCommittedDataset) {\n                        this.page(1); // reset page as a new dataset has been supplied\n                    }\n                    isCommittedDataset = false;\n                    var fireEvent = function () {\n                        ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n                    };\n                    if (initialEvents) {\n                        initialEvents.push(fireEvent);\n                    }\n                    else {\n                        fireEvent();\n                    }\n                }\n                log('ngTable: set settings', _settings);\n                return this;\n            }\n            return _settings;\n        };\n        this.page = function (page) {\n            return page !== undefined ? this.parameters({\n                'page': page\n            }) : _params.page;\n        };\n        this.total = function (total) {\n            return total !== undefined ? this.settings({\n                'total': total\n            }) : _settings.total;\n        };\n        this.count = function (count) {\n            // reset to first page because can be blank page\n            return count !== undefined ? this.parameters({\n                'count': count,\n                'page': 1\n            }) : _params.count;\n        };\n        this.filter = function (filter) {\n            if (filter != null && typeof filter === 'object') {\n                return this.parameters({\n                    'filter': filter,\n                    'page': 1\n                });\n            }\n            else if (filter === true) {\n                var keys = Object.keys(_params.filter);\n                var significantFilter = {};\n                for (var i = 0; i < keys.length; i++) {\n                    var filterValue = _params.filter[keys[i]];\n                    if (filterValue != null && filterValue !== '') {\n                        significantFilter[keys[i]] = filterValue;\n                    }\n                }\n                return significantFilter;\n            }\n            else {\n                return _params.filter;\n            }\n        };\n        this.group = function (group, sortDirection) {\n            if (group === undefined) {\n                return _params.group;\n            }\n            var newParameters = {\n                page: 1\n            };\n            if (isGroupingFun(group) && sortDirection !== undefined) {\n                group.sortDirection = sortDirection;\n                newParameters.group = group;\n            }\n            else if (typeof group === 'string' && sortDirection !== undefined) {\n                newParameters.group = (_a = {}, _a[group] = sortDirection, _a);\n            }\n            else {\n                newParameters.group = group;\n            }\n            this.parameters(newParameters);\n            return this;\n            var _a;\n        };\n        /**\n         * @ngdoc method\n         * @name NgTableParams#sorting\n         * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n         *\n         * @param {string} sorting New sorting\n         * @returns {Object} Current sorting or `this`\n         */\n        this.sorting = function (sorting, direction) {\n            if (typeof sorting === 'string' && direction !== undefined) {\n                this.parameters({\n                    'sorting': (_a = {}, _a[sorting] = direction, _a)\n                });\n                return this;\n            }\n            return sorting !== undefined ? this.parameters({\n                'sorting': sorting\n            }) : _params.sorting;\n            var _a;\n        };\n        this.isSortBy = function (field, direction) {\n            if (direction !== undefined) {\n                return _params.sorting[field] !== undefined && _params.sorting[field] == direction;\n            }\n            else {\n                return _params.sorting[field] !== undefined;\n            }\n        };\n        /**\n         * @ngdoc method\n         * @name NgTableParams#orderBy\n         * @description Return object of sorting parameters for angular filter\n         *\n         * @returns {Array} Array like: [ '-name', '+age' ]\n         */\n        this.orderBy = function () {\n            return convertSortToOrderBy(_params.sorting);\n        };\n        function convertSortToOrderBy(sorting) {\n            var result = [];\n            for (var column in sorting) {\n                result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n            }\n            return result;\n        }\n        /**\n         * @ngdoc method\n         * @name NgTableParams#generatePagesArray\n         * @description Generate array of pages\n         *\n         * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n         *\n         * @param {boolean} currentPage which page must be active\n         * @param {boolean} totalItems  Total quantity of items\n         * @param {boolean} pageSize    Quantity of items on page\n         * @param {number} maxBlocks    Quantity of blocks for pagination\n         * @returns {Array} Array of pages\n         */\n        this.generatePagesArray = function (currentPage, totalItems, pageSize, maxBlocks) {\n            if (!arguments.length) {\n                currentPage = this.page();\n                totalItems = this.total();\n                pageSize = this.count();\n            }\n            var maxPage, maxPivotPages, minPage, numPages;\n            maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n            var pages = [];\n            numPages = Math.ceil(totalItems / pageSize);\n            if (numPages > 1) {\n                pages.push({\n                    type: 'prev',\n                    number: Math.max(1, currentPage - 1),\n                    active: currentPage > 1\n                });\n                pages.push({\n                    type: 'first',\n                    number: 1,\n                    active: currentPage > 1,\n                    current: currentPage === 1\n                });\n                maxPivotPages = Math.round((_settings.paginationMaxBlocks - _settings.paginationMinBlocks) / 2);\n                minPage = Math.max(2, currentPage - maxPivotPages);\n                maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n                minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n                var i = minPage;\n                while (i <= maxPage) {\n                    if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                        pages.push({\n                            type: 'more',\n                            active: false\n                        });\n                    }\n                    else {\n                        pages.push({\n                            type: 'page',\n                            number: i,\n                            active: currentPage !== i,\n                            current: currentPage === i\n                        });\n                    }\n                    i++;\n                }\n                pages.push({\n                    type: 'last',\n                    number: numPages,\n                    active: currentPage !== numPages,\n                    current: currentPage === numPages\n                });\n                pages.push({\n                    type: 'next',\n                    number: Math.min(numPages, currentPage + 1),\n                    active: currentPage < numPages\n                });\n            }\n            return pages;\n        };\n        /**\n         * @ngdoc method\n         * @name NgTableParams#isDataReloadRequired\n         * @description Return true when a change to this `NgTableParams` instance should require the reload method\n         * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n         *\n         * Note that this method will return false when the reload method has run but fails. In this case\n         * `hasErrorState` will return true.\n         */\n        this.isDataReloadRequired = function () {\n            // note: using != as want to treat null and undefined the same\n            return !isCommittedDataset || !ng1.equals(createComparableParams(), prevParamsMemento)\n                || hasGlobalSearchFieldChanges();\n        };\n        function createComparableParams() {\n            var group = _params.group;\n            return {\n                params: _params,\n                groupSortDirection: isGroupingFun(group) ? group.sortDirection : undefined\n            };\n        }\n        function isGroupingFun(val) {\n            return typeof val === 'function';\n        }\n        /**\n         * @ngdoc method\n         * @name NgTableParams#hasFilter\n         * @description Determines if NgTableParams#filter has significant filter value(s)\n         * (any value except null, undefined, or empty string)\n         * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n         */\n        this.hasFilter = function () {\n            return Object.keys(this.filter(true)).length > 0;\n        };\n        this.hasGroup = function (group, sortDirection) {\n            if (group == null) {\n                return isGroupingFun(_params.group) || Object.keys(_params.group).length > 0;\n            }\n            if (isGroupingFun(group)) {\n                if (sortDirection == null) {\n                    return _params.group === group;\n                }\n                else {\n                    return _params.group === group && group.sortDirection === sortDirection;\n                }\n            }\n            else {\n                if (sortDirection == null) {\n                    return Object.keys(_params.group).indexOf(group) !== -1;\n                }\n                else {\n                    return _params.group[group] === sortDirection;\n                }\n            }\n        };\n        this.hasFilterChanges = function () {\n            var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);\n            return !ng1.equals((_params.filter), previousFilter) || hasGlobalSearchFieldChanges();\n        };\n        function hasGlobalSearchFieldChanges() {\n            var currentVal = (_params.filter && _params.filter['$']);\n            var previousVal = (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter['$']);\n            return !ng1.equals(currentVal, previousVal);\n        }\n        this.url = function (asString) {\n            // this function is an example of Typescript gone bad!!\n            asString = asString || false;\n            var pairs = (asString ? [] : {});\n            for (var key in _params) {\n                if (_params.hasOwnProperty(key)) {\n                    var item = _params[key], name = encodeURIComponent(key);\n                    if (typeof item === \"object\") {\n                        for (var subkey in item) {\n                            if (isSignificantValue(item[subkey], key)) {\n                                var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                                collectValue(item[subkey], pname);\n                            }\n                        }\n                    }\n                    else if (!ng1.isFunction(item) && isSignificantValue(item, key)) {\n                        collectValue(item, name);\n                    }\n                }\n            }\n            return pairs;\n            function collectValue(value, key) {\n                if (isArray(pairs)) {\n                    pairs.push(key + \"=\" + encodeURIComponent(value));\n                }\n                else {\n                    pairs[key] = encodeURIComponent(value);\n                }\n            }\n            function isArray(pairs) {\n                return asString;\n            }\n            function isSignificantValue(value, key) {\n                return key === \"group\" ? true : typeof value !== undefined && value !== \"\";\n            }\n        };\n        this.reload = function () {\n            var self = this, pData = null;\n            _settings.$loading = true;\n            prevParamsMemento = ng1.copy(createComparableParams());\n            isCommittedDataset = true;\n            if (self.hasGroup()) {\n                pData = runInterceptorPipeline($q.when(_settings.getGroups(self)));\n            }\n            else {\n                var fn = _settings.getData;\n                pData = runInterceptorPipeline($q.when(fn(self)));\n            }\n            log('ngTable: reload data');\n            var oldData = self.data;\n            return pData.then(function (data) {\n                _settings.$loading = false;\n                errParamsMemento = null;\n                self.data = data;\n                // note: I think it makes sense to publish this event even when data === oldData\n                // subscribers can always set a filter to only receive the event when data !== oldData\n                ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n                self.reloadPages();\n                return data;\n            }).catch(function (reason) {\n                errParamsMemento = prevParamsMemento;\n                // \"rethrow\"\n                return $q.reject(reason);\n            });\n        };\n        this.hasErrorState = function () {\n            return !!(errParamsMemento && ng1.equals(errParamsMemento, createComparableParams()));\n        };\n        function optimizeFilterDelay() {\n            // don't debounce by default filter input when working with small synchronous datasets\n            if (_settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&\n                _settings.total <= _settings.filterOptions.filterDelayThreshold &&\n                _settings.getData === defaultSettingsFns.getData) {\n                _settings.filterOptions.filterDelay = 0;\n            }\n        }\n        this.reloadPages = (function () {\n            var currentPages;\n            return function () {\n                var oldPages = currentPages;\n                var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n                if (!ng1.equals(oldPages, newPages)) {\n                    currentPages = newPages;\n                    ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n                }\n            };\n        })();\n        function runInterceptorPipeline(fetchedData) {\n            var interceptors = _settings.interceptors || [];\n            return interceptors.reduce(function (result, interceptor) {\n                var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;\n                var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;\n                return result.then(function (data) {\n                    return thenFn(data, self);\n                }, function (reason) {\n                    return rejectFn(reason, self);\n                });\n            }, fetchedData);\n        }\n        function getDefaultSettingFns() {\n            return {\n                getData: getData,\n                getGroups: getGroups\n            };\n            /**\n             * @ngdoc method\n             * @name settings#getData\n             * @description Returns the data to display in the table\n             *\n             * Called by `NgTableParams` whenever it considers new data is to be loaded\n             *\n             * @param {Object} params the `NgTableParams` requesting data\n             */\n            function getData(params) {\n                return ngTableDefaultGetData(params.settings().dataset, params);\n            }\n            /**\n             * @ngdoc method\n             * @name settings#getGroups\n             * @description Return groups of data to display in the table\n             *\n             * Called by `NgTableParams` whenever it considers new data is to be loaded\n             * and when a `group` value has been assigned\n             *\n             * @param {Object} params the `NgTableParams` requesting data\n             */\n            function getGroups(params) {\n                var group = params.group();\n                var groupFn;\n                var sortDirection = undefined;\n                if (isGroupingFun(group)) {\n                    groupFn = group;\n                    sortDirection = group.sortDirection;\n                }\n                else {\n                    // currently support for only one group implemented\n                    var groupField = Object.keys(group)[0];\n                    sortDirection = group[groupField];\n                    groupFn = function (item) {\n                        return getPath(item, groupField);\n                    };\n                }\n                var settings = params.settings();\n                var originalDataOptions = settings.dataOptions;\n                settings.dataOptions = { applyPaging: false };\n                var getData = settings.getData;\n                var gotData = $q.when(getData(params));\n                return gotData.then(function (data) {\n                    var groups = {};\n                    ng1.forEach(data, function (item) {\n                        var groupName = groupFn(item);\n                        groups[groupName] = groups[groupName] || {\n                            data: [],\n                            $hideRows: !settings.groupOptions.isExpanded,\n                            value: groupName\n                        };\n                        groups[groupName].data.push(item);\n                    });\n                    var result = [];\n                    for (var i in groups) {\n                        result.push(groups[i]);\n                    }\n                    if (sortDirection) {\n                        var orderByFn = ngTableDefaultGetData.getOrderByFn();\n                        var orderBy = convertSortToOrderBy({\n                            value: sortDirection\n                        });\n                        result = orderByFn(result, orderBy);\n                    }\n                    return ngTableDefaultGetData.applyPaging(result, params);\n                }).finally(function () {\n                    // restore the real options\n                    settings.dataOptions = originalDataOptions;\n                });\n            }\n            function getPath(obj, ks) {\n                // origianl source https://github.com/documentcloud/underscore-contrib\n                var keys;\n                if (typeof ks === \"string\") {\n                    keys = ks.split(\".\");\n                }\n                else {\n                    keys = ks;\n                }\n                // If we have reached an undefined property\n                // then stop executing and return undefined\n                if (obj === undefined)\n                    return void 0;\n                // If the path array has no more elements, we've reached\n                // the intended property and return its value\n                if (keys.length === 0)\n                    return obj;\n                // If we still have elements in the path array and the current\n                // value is null, stop executing and return undefined\n                if (obj === null)\n                    return void 0;\n                return getPath(obj[keys[0]], keys.slice(1));\n            }\n        }\n        var _params = {\n            page: 1,\n            count: 10,\n            filter: {},\n            sorting: {},\n            group: {}\n        };\n        ng1.extend(_params, ngTableDefaults.params);\n        /**\n         * @ngdoc object\n         * @name settings\n         * @module ngTable\n         * @description configuration settings for `NgTableParams`\n         */\n        var _settings = {\n            $loading: false,\n            dataset: null,\n            total: 0,\n            defaultSort: 'desc',\n            filterOptions: ng1.copy(defaultFilterOptions),\n            groupOptions: ng1.copy(defaultGroupOptions),\n            counts: [10, 25, 50, 100],\n            interceptors: [],\n            paginationMaxBlocks: 11,\n            paginationMinBlocks: 5,\n            sortingIndicator: 'span'\n        };\n        this.settings(defaultSettingsFns);\n        this.settings(ngTableDefaults.settings);\n        this.settings(baseSettings);\n        this.parameters(baseParameters, true);\n        ngTableEventsChannel.publishAfterCreated(this);\n        // run events during construction after the initial create event. That way a consumer\n        // can subscribe to all events for a table without \"dropping\" an event\n        ng1.forEach(initialEvents, function (event) {\n            event();\n        });\n        initialEvents = null;\n        return this;\n    }\n}\nexports.ngTableParamsFactory = ngTableParamsFactory;\n\n\n/***/ },\n/* 23 */\n18,\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filterRow.html';\nvar html = \"<tr ng-show=show_filter class=ng-table-filters> <th data-title-text=\\\"{{$column.titleAlt(this) || $column.title(this)}}\\\" ng-repeat=\\\"$column in $columns\\\" ng-if=$column.show(this) class=\\\"filter {{$column.class(this)}}\\\" ng-class=\\\"params.settings().filterOptions.filterLayout === 'horizontal' ? 'filter-horizontal' : ''\\\"> <div ng-repeat=\\\"(name, filter) in $column.filter(this)\\\" ng-include=config.getTemplateUrl(filter) class=filter-cell ng-class=\\\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? 'last' : '']\\\"> </div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/number.html';\nvar html = \"<input type=number name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/select-multiple.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $column.data\\\" ng-disabled=$filterRow.disabled multiple=multiple ng-multiple=true ng-model=params.filter()[name] class=\\\"filter filter-select-multiple form-control\\\" name={{name}}> </select> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/select.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $selectData\\\" ng-table-select-filter-ds=$column ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"filter filter-select form-control\\\" name={{name}}> <option style=display:none value=\\\"\\\"></option> </select> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/text.html';\nvar html = \"<input type=text name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/groupRow.html';\nvar html = \"<tr ng-if=params.hasGroup() ng-show=$groupRow.show class=ng-table-group-header> <th colspan={{getVisibleColumns().length}} class=sortable ng-class=\\\"{\\n                    'sort-asc': params.hasGroup($selGroup, 'asc'),\\n                    'sort-desc':params.hasGroup($selGroup, 'desc')\\n                  }\\\"> <a href=\\\"\\\" ng-click=\\\"isSelectorOpen = !isSelectorOpen\\\" class=ng-table-group-selector> <strong class=sort-indicator>{{$selGroupTitle}}</strong> <button class=\\\"btn btn-default btn-xs ng-table-group-close\\\" ng-click=\\\"$groupRow.show = false; $event.preventDefault(); $event.stopPropagation();\\\"> <span class=\\\"glyphicon glyphicon-remove\\\"></span> </button> <button class=\\\"btn btn-default btn-xs ng-table-group-toggle\\\" ng-click=\\\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\\\"> <span class=glyphicon ng-class=\\\"{\\n                    'glyphicon-resize-small': params.settings().groupOptions.isExpanded,\\n                    'glyphicon-resize-full': !params.settings().groupOptions.isExpanded\\n                }\\\"></span> </button> </a> <div class=list-group ng-if=isSelectorOpen> <a href=\\\"\\\" class=list-group-item ng-repeat=\\\"group in getGroupables()\\\" ng-click=groupBy(group)> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\\\"isSelectedGroup(group) && 'sort-indicator'\\\"></strong> </a> </div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/header.html';\nvar html = \"<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/pager.html';\nvar html = \"<div class=\\\"ng-cloak ng-table-pager\\\" ng-if=params.data.length> <div ng-if=params.settings().counts.length class=\\\"ng-table-counts btn-group pull-right\\\"> <button ng-repeat=\\\"count in params.settings().counts\\\" type=button ng-class=\\\"{'active':params.count() == count}\\\" ng-click=params.count(count) class=\\\"btn btn-default\\\"> <span ng-bind=count></span> </button> </div> <ul ng-if=pages.length class=\\\"pagination ng-table-pagination\\\"> <li ng-class=\\\"{'disabled': !page.active && !page.current, 'active': page.current}\\\" ng-repeat=\\\"page in pages\\\" ng-switch=page.type> <a ng-switch-when=prev ng-click=params.page(page.number) href=\\\"\\\">&laquo;</a> <a ng-switch-when=first ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=page ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=more ng-click=params.page(page.number) href=\\\"\\\">&#8230;</a> <a ng-switch-when=last ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=next ng-click=params.page(page.number) href=\\\"\\\">&raquo;</a> </li> </ul> </div> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/sorterRow.html';\nvar html = \"<tr class=ng-table-sort-header> <th title={{$column.headerTitle(this)}} ng-repeat=\\\"$column in $columns\\\" ng-class=\\\"{\\n                    'sortable': $column.sortable(this),\\n                    'sort-asc': params.sorting()[$column.sortable(this)]=='asc',\\n                    'sort-desc': params.sorting()[$column.sortable(this)]=='desc'\\n                  }\\\" ng-click=\\\"sortBy($column, $event)\\\" ng-if=$column.show(this) ng-init=\\\"template = $column.headerTemplateURL(this)\\\" class=\\\"header {{$column.class(this)}}\\\"> <div ng-if=!template class=ng-table-header ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'div'}\\\"> <span ng-bind=$column.title(this) ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'span'}\\\"></span> </div> <div ng-if=template ng-include=template></div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar ng1 = __webpack_require__(0);\nvar core_1 = __webpack_require__(2);\nvar browser_1 = __webpack_require__(1);\nvar ngTable = ng1.module('ngTable', [core_1.default.name, browser_1.default.name]);\nexports.ngTable = ngTable;\n__export(__webpack_require__(2));\n__export(__webpack_require__(1));\n\n\n/***/ }\n/******/ ])))\n});\n;\n\n\n// WEBPACK FOOTER //\n// ng-table.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 33);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e357bfb9357d911d16d7","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 0\n// module chunks = 0","import * as angular from 'angular';\nimport { ngTable } from './ngTable.directive';\nimport { ngTableColumn } from './ngTableColumn';\nimport { ngTableColumnsBinding } from './ngTableColumnsBinding.directive';\nimport { ngTableController } from './ngTableController';\nimport { ngTableDynamic } from './ngTableDynamic.directive';\nimport { ngTableFilterConfigProvider } from './ngTableFilterConfig';\nimport { ngTableFilterRow } from './ngTableFilterRow.directive';\nimport { ngTableFilterRowController } from './ngTableFilterRowController';\nimport { ngTableGroupRow } from './ngTableGroupRow.directive';\nimport { ngTableGroupRowController } from './ngTableGroupRowController';\nimport { ngTablePagination } from './ngTablePagination.directive';\nimport { ngTableSelectFilterDs } from './ngTableSelectFilterDs.directive';\nimport { ngTableSorterRow } from './ngTableSorterRow.directive';\nimport { ngTableSorterRowController } from './ngTableSorterRowController';\nimport './filters/number.html';\nimport './filters/select.html';\nimport './filters/select-multiple.html';\nimport './filters/text.html';\nimport './pager.html';\nimport './header.html';\n\nexport default angular.module('ngTable-browser', [])\n    .directive('ngTable', ngTable)\n    .factory('ngTableColumn', ngTableColumn)\n    .directive('ngTableColumnsBinding', ngTableColumnsBinding)\n    .controller('ngTableController', ngTableController)\n    .directive('ngTableDynamic', ngTableDynamic)\n    .provider('ngTableFilterConfig', ngTableFilterConfigProvider as any)\n    .directive('ngTableFilterRow', ngTableFilterRow)\n    .controller('ngTableFilterRowController', ngTableFilterRowController)\n    .directive('ngTableGroupRow', ngTableGroupRow)\n    .controller('ngTableGroupRowController', ngTableGroupRowController)\n    .directive('ngTablePagination', ngTablePagination)\n    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs)\n    .directive('ngTableSorterRow', ngTableSorterRow)\n    .controller('ngTableSorterRowController', ngTableSorterRowController);\n\nexport * from './public-interfaces';\n\n\n// WEBPACK FOOTER //\n// ./src/browser/index.ts","import * as angular from 'angular';\nimport { ngTableDefaultGetDataProvider } from './ngTableDefaultGetData';\nimport { ngTableDefaults } from './ngTableDefaults';\nimport { ngTableParamsFactory } from './ngTableParams';\nimport { ngTableEventsChannel } from './ngTableEventsChannel';\n\nexport default angular.module('ngTable-core', [])\n    .provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider)\n    .value('ngTableDefaults',ngTableDefaults)\n    .factory('NgTableParams', ngTableParamsFactory)\n    .factory('ngTableEventsChannel', ngTableEventsChannel);\n\nexport * from './public-interfaces';\n\n\n// WEBPACK FOOTER //\n// ./src/core/index.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\nimport { IAugmentedJQuery, IDirective, IQService, IParseService, IPromise, IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { \n    IColumnDef, ColumnFieldContext, IColumnField, IFilterTemplateDefMap, SelectData, ITableController, \n    ITableInputAttributes \n} from './public-interfaces';\n\ninterface IScopeExtensions {\n    $columns: IColumnDef[]\n}\n\nngTable.$inject = ['$q', '$parse'];\n\n/**\n * Directive that instantiates {@link ngTableController ngTableController}.\n * @ngdoc directive\n * @name ngTable\n * @example\n * \n * ```html\n * <table ng-table=\"$ctrl.tableParams\" show-filter=\"true\" class=\"table table-bordered\">\n *  <tr ng-repeat=\"user in $data\">\n *      <td data-title=\"'Name'\" sortable=\"'name'\" filter=\"{ 'name': 'text' }\">\n *          {{user.name}}\n *      </td>\n *      <td data-title=\"'Age'\" sortable=\"'age'\" filter=\"{ 'age': 'text' }\">\n *          {{user.age}}\n *      </td>\n *  </tr>\n * </table>\n * ```\n */\nexport function ngTable($q: IQService, $parse: IParseService) : IDirective {\n\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function(element: IAugmentedJQuery) {\n            var columns: IColumnDef[] = [],\n                i = 0,\n                dataRow: IAugmentedJQuery,\n                groupRow: IAugmentedJQuery,\n                rows: IAugmentedJQuery[] = [];\n\n            ng1.forEach(element.find('tr'), function(tr) {\n                rows.push(ng1.element(tr))\n            });\n            dataRow = rows.filter(function(tr){\n                return !tr.hasClass('ng-table-group');\n            })[0];\n            groupRow = rows.filter(function(tr){\n                return tr.hasClass('ng-table-group');\n            })[0];\n\n            if (!dataRow) {\n                return undefined;\n            }\n            ng1.forEach(dataRow.find('td'), function(item) {\n                var el = ng1.element(item);\n                if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                    return;\n                }\n\n                var getAttrValue = function(attr: string){\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                var setAttrValue = function(attr: string, value: string){\n                    if (el.attr('x-data-' + attr)){\n                        el.attr('x-data-' + attr, value)\n                    } else if (el.attr('data' + attr)){\n                        el.attr('data' + attr, value)\n                    } else {\n                        el.attr(attr, value)\n                    }\n                };\n\n                var parsedAttribute = function<T>(attr: string): IColumnField<T> {\n                    var expr = getAttrValue(attr);\n                    if (!expr){\n                        return undefined;\n                    }\n\n                    var localValue: any;\n                    var getter = function (context: ColumnFieldContext) {\n                        if (localValue !== undefined){\n                            return localValue as T;\n                        }\n                        return $parse(expr)(context) as T;\n                    };\n                    (getter as any).assign = function($scope: ColumnFieldContext, value: any){\n                        var parsedExpr = $parse(expr);\n                        if (parsedExpr.assign) {\n                            // we should be writing back to the parent scope as this is where the expression\n                            // came from\n                            parsedExpr.assign($scope.$parent, value);\n                        } else {\n                            localValue = value;\n                        }\n                    };\n                    return getter as IColumnField<T>;\n                };\n                var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                if (titleExpr){\n                    el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                }\n                // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                // a corresponding \"safe\" default\n                columns.push({\n                    id: i++,\n                    title: parsedAttribute<string>('title'),\n                    titleAlt: parsedAttribute<string>('title-alt'),\n                    headerTitle: parsedAttribute<string>('header-title'),\n                    sortable: parsedAttribute<string | boolean>('sortable'),\n                    'class': parsedAttribute<string>('header-class'),\n                    filter: parsedAttribute<IFilterTemplateDefMap>('filter'),\n                    groupable: parsedAttribute<string | boolean>('groupable'),\n                    headerTemplateURL: parsedAttribute<string | boolean>('header'),\n                    filterData: parsedAttribute<IPromise<SelectData> | SelectData>('filter-data'),\n                    show: el.attr(\"ng-if\") ? parsedAttribute<boolean>('ng-if') : undefined\n                });\n\n                if (groupRow || el.attr(\"ng-if\")){\n                    // change ng-if to bind to our column definition which we know will be writable\n                    // because this will potentially increase the $watch count, only do so if we already have an\n                    // ng-if or when we definitely need to change visibility of the columns.\n                    // currently only ngTableGroupRow directive needs to change visibility\n                    setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n                }\n            });\n            return function(scope: IScope & IScopeExtensions, element: IAugmentedJQuery, attrs: ITableInputAttributes, controller: ITableController) {\n                scope.$columns = columns = controller.buildColumns(columns);\n\n                controller.setupBindingsToInternalScope(attrs.ngTable);\n                controller.loadFilterData(columns);\n                controller.compileDirectiveTemplates();\n            };\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTable.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { IColumnDef, IDynamicTableColDef } from './public-interfaces';\n\n/**\n * @private\n * Definition of the service used to construct a table $column used by {@link ngTable ngTable} directive\n */\nexport interface IColumnBuilder {\n    /**\n     * Creates a $column for use within a header template\n     *\n     * @param column the initial definition for $column to build\n     * @param defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n     * @param columns a reference to the $columns array to make available on the context supplied to the\n     * $column getter methods\n     */\n    buildColumn(column: IColumnDef | IDynamicTableColDef, defaultScope: IScope, columns: Array<IColumnDef | IDynamicTableColDef>): IColumnDef | IDynamicTableColDef\n}\n\nngTableColumn.$inject = [];\n\n/**\n * @private\n * Service to construct a $column definition used by {@link ngTable ngTable} directive\n */\nexport function ngTableColumn(): IColumnBuilder {\n\n    return {\n        buildColumn: buildColumn\n    };\n\n    //////////////\n\n    function buildColumn(column: IColumnDef | IDynamicTableColDef, defaultScope: IScope, columns: IColumnDef[]): IColumnDef | IDynamicTableColDef {\n        // note: we're not modifying the original column object. This helps to avoid unintended side affects\n        var extendedCol = Object.create(column);\n        var defaults = createDefaults();\n        for (var prop in defaults) {\n            if (extendedCol[prop] === undefined) {\n                extendedCol[prop] = defaults[prop];\n            }\n            if(!ng1.isFunction(extendedCol[prop])){\n                // wrap raw field values with \"getter\" functions\n                // - this is to ensure consistency with how ngTable.compile builds columns\n                // - note that the original column object is being \"proxied\"; this is important\n                //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                (function(prop1: string){\n                    var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n                        if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                            (getterSetter as any).assign(null, arguments[0]);\n                        } else {\n                            return column[prop1];\n                        }\n                    };\n                    (getterSetter as any).assign = function($scope: IScope, value: any){\n                        column[prop1] = value;\n                    };\n                    extendedCol[prop1] = getterSetter;\n                })(prop);\n            }\n            (function(prop1: string){\n                // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n                var getterFn = extendedCol[prop1];\n                extendedCol[prop1] = function () {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])){\n                        getterFn.assign(null, arguments[0]);\n                    } else {\n                        var scope = arguments[0] || defaultScope;\n                        var context = Object.create(scope);\n                        ng1.extend(context, {\n                            $column: extendedCol,\n                            $columns: columns\n                        });\n                        return getterFn.call(column, context);\n                    }\n                };\n                if (getterFn.assign){\n                    extendedCol[prop1].assign = getterFn.assign;\n                }\n            })(prop);\n        }\n        return extendedCol;\n    }\n\n    function createDefaults(){\n        return {\n            'class': createGetterSetter(''),\n            filter: createGetterSetter(false),\n            groupable: createGetterSetter(false),\n            filterData: ng1.noop,\n            headerTemplateURL: createGetterSetter(false),\n            headerTitle: createGetterSetter(''),\n            sortable: createGetterSetter(false),\n            show: createGetterSetter(true),\n            title: createGetterSetter(''),\n            titleAlt: createGetterSetter('')\n        };\n    }\n\n    function createGetterSetter(initialValue: any){\n        var value = initialValue;\n        var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/){\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                (getterSetter as any).assign(null, arguments[0]);\n            } else {\n                return value;\n            }\n        };\n        (getterSetter as any).assign = function($scope: IScope, newValue: any){\n            value = newValue;\n        };\n        return getterSetter;\n    }\n\n    function isScopeLike(object: any){\n        return object != null && ng1.isFunction(object.$new);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableColumn.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IAugmentedJQuery, IAttributes, IDirective, IParseService } from 'angular';\nimport { ITableScope } from './ngTableController';\nimport { IColumnDef } from './public-interfaces';\n\n/**\n * @private\n */\ninterface IInputAttributes extends IAttributes {\n    ngTableColumnsBinding: string;\n}\n\nngTableColumnsBinding.$inject = [\"$parse\"];\n\n/**\n * One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n * expression.\n * This allows the $columns array created for the table to be accessed outside of the html table\n * markup.\n * \n * @ngdoc directive\n * \n * @example\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" class=\"table\" ng-table-columns-binding=\"$ctlr.tableColumns\">\n * ```\n */\nexport function ngTableColumnsBinding<T>($parse: IParseService) : IDirective {\n    var directive = {\n        restrict: 'A',\n        require: 'ngTable',\n        link: linkFn\n    };\n    return directive;\n\n    function linkFn($scope: ITableScope<T>, $element: IAugmentedJQuery, $attrs: IInputAttributes){\n        var setter = $parse($attrs.ngTableColumnsBinding).assign;\n        if (setter){\n            $scope.$watch<IColumnDef[]>('$columns', function(newColumns){\n                var shallowClone = (newColumns || []).slice(0);\n                setter($scope, shallowClone);\n            });\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableColumnsBinding.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { \n    IAttributes, IAugmentedJQuery, ICompileService, IDocumentService, IParseService, IPromise, IScope, \n    ITimeoutService \n} from 'angular';\nimport * as ng1 from 'angular';\nimport { \n    DataResult, DataResults, IDataRowGroup, GroupedDataResults, INgTableParams, IEventsChannel, \n    IPageButton, ITableParamsConstructor \n} from '../core';\nimport { IColumnDef, IDynamicTableColDef, SelectData, ITableInputAttributes } from './public-interfaces';\nimport { IColumnBuilder } from './ngTableColumn';\n\n/**\n * @private\n */\nexport interface ITableScope<T> extends IScope {\n    $columns: IColumnDef[];\n    $loading: boolean;\n    $filterRow: {\n        disabled: boolean;\n    };\n    $data?: DataResults<T>;\n    $groups?: GroupedDataResults<T>;\n    $groupRow: {\n        show: boolean;\n    };\n    show_filter: boolean;\n    pages: IPageButton[];\n    templates: {\n        header: string;\n        pagination: string;\n    },\n    params: INgTableParams<T>\n}\n\nngTableController.$inject = [\n    '$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element', '$document', 'ngTableColumn', 'ngTableEventsChannel'\n];\n\n/**\n * The controller for the {@link ngTable ngTable} and {@link ngTableDynamic ngTableDynamic} directives\n */\nexport function ngTableController<T>(\n    $scope: ITableScope<T>, NgTableParams: ITableParamsConstructor<T>, $timeout: ITimeoutService, $parse: IParseService,\n    $compile: ICompileService, $attrs: IAttributes & ITableInputAttributes, $element: IAugmentedJQuery, $document: IDocumentService,\n    ngTableColumn: IColumnBuilder, ngTableEventsChannel: IEventsChannel) {\n    var isFirstTimeLoad = true;\n    $scope.$filterRow = { disabled: false };\n    $scope.$loading = false;\n\n    // until such times as the directive uses an isolated scope, we need to ensure that the check for\n    // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n    // field on a $scope higher up in the prototype chain\n    if (!$scope.hasOwnProperty(\"params\")) {\n        $scope.params = new NgTableParams(true);\n    }\n\n    var delayFilter = (function () {\n        var timer: IPromise<any>;\n        return function (callback: (...args: any[]) => void, ms: number) {\n            $timeout.cancel(timer);\n            timer = $timeout(callback, ms);\n        };\n    })();\n\n    function onDataReloadStatusChange(newStatus: boolean/*, oldStatus*/) {\n        if (!newStatus || $scope.params.hasErrorState()) {\n            return;\n        }\n\n        var currentParams = $scope.params;\n        var filterOptions = currentParams.settings().filterOptions;\n\n        if (currentParams.hasFilterChanges()) {\n            var applyFilter = function () {\n                currentParams.page(1);\n                currentParams.reload();\n            };\n            if (filterOptions.filterDelay) {\n                delayFilter(applyFilter, filterOptions.filterDelay);\n            } else {\n                applyFilter();\n            }\n        } else {\n            currentParams.reload();\n        }\n    }\n\n    // watch for when a new NgTableParams is bound to the scope\n    // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n    // the current data page as a field. Checking this for value equality would be terrible for performance\n    // and potentially cause an error if the items in that array has circular references\n    $scope.$watch<INgTableParams<T>>('params', (newParams, oldParams) => {\n        if (newParams === oldParams || !newParams) {\n            return;\n        }\n\n        newParams.reload();\n    }, false);\n\n    $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n\n    this.compileDirectiveTemplates = function () {\n        if (!$element.hasClass('ng-table')) {\n            $scope.templates = {\n                header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n                pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n            };\n            $element.addClass('ng-table');\n            var headerTemplate: IAugmentedJQuery = null;\n\n            // $element.find('> thead').length === 0 doesn't work on jqlite\n            var theadFound = false;\n            ng1.forEach($element.children(), function (e) {\n                if (e.tagName === 'THEAD') {\n                    theadFound = true;\n                }\n            });\n            if (!theadFound) {\n                headerTemplate = ng1.element('<thead ng-include=\"templates.header\"></thead>', $document);\n                $element.prepend(headerTemplate);\n            }\n            var paginationTemplate = ng1.element(\n                '<div ng-table-pagination=\"params\" template-url=\"templates.pagination\"></div>',\n                $document\n            );\n            $element.after(paginationTemplate);\n            if (headerTemplate) {\n                $compile(headerTemplate)($scope);\n            }\n            $compile(paginationTemplate)($scope);\n        }\n    };\n\n    this.loadFilterData = function ($columns: IColumnDef[]) {\n        ng1.forEach($columns, function ($column) {\n            var result = $column.filterData($scope);\n            if (!result) {\n                delete $column.filterData;\n                return undefined;\n            }\n\n            if (isPromiseLike(result)) {\n                delete $column.filterData;\n                return result.then(function (data) {\n                    // our deferred can eventually return arrays, functions and objects\n                    if (!ng1.isArray(data) && !ng1.isFunction(data) && !ng1.isObject(data)) {\n                        // if none of the above was found - we just want an empty array\n                        data = [];\n                    }\n                    $column.data = data;\n                });\n            }\n            // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n            else {\n                return $column.data = result;\n            }\n        });\n\n        function isPromiseLike(val: any): val is IPromise<SelectData> {\n            return val && typeof val === 'object' && typeof val.then === 'function';\n        }\n    };\n\n    this.buildColumns = function (columns: Array<IColumnDef | IDynamicTableColDef>) {\n        var result: Array<IColumnDef | IDynamicTableColDef> = [];\n        (columns || []).forEach(function (col) {\n            result.push(ngTableColumn.buildColumn(col, $scope, result));\n        });\n        return result\n    };\n\n    this.parseNgTableDynamicExpr = function (attr: string) {\n        if (!attr || attr.indexOf(\" with \") > -1) {\n            var parts = attr.split(/\\s+with\\s+/);\n            return {\n                tableParams: parts[0],\n                columns: parts[1]\n            };\n        } else {\n            throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n        }\n    };\n\n    this.setupBindingsToInternalScope = function (tableParamsExpr: string) {\n\n        // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n        // $watch for value equivalence. This is because ngTableParams references the current page of data as\n        // a field and it's important not to watch this\n        $scope.$watch<INgTableParams<T>>(tableParamsExpr, function (params) {\n            if (params === undefined) {\n                return;\n            }\n            $scope.params = params;\n        }, false);\n\n        setupFilterRowBindingsToInternalScope();\n        setupGroupRowBindingsToInternalScope();\n    };\n\n    function setupFilterRowBindingsToInternalScope() {\n        if ($attrs.showFilter) {\n            $scope.$parent.$watch<boolean>($attrs.showFilter, function (value) {\n                $scope.show_filter = value;\n            });\n        } else {\n            $scope.$watch(hasVisibleFilterColumn, function (value) {\n                $scope.show_filter = value;\n            })\n        }\n\n        if ($attrs.disableFilter) {\n            $scope.$parent.$watch<boolean>($attrs.disableFilter, function (value) {\n                $scope.$filterRow.disabled = value;\n            });\n        }\n    }\n\n    function setupGroupRowBindingsToInternalScope() {\n        $scope.$groupRow = { show: false };\n        if ($attrs.showGroup) {\n            var showGroupGetter = $parse($attrs.showGroup);\n            $scope.$parent.$watch<boolean>(showGroupGetter, function (value) {\n                $scope.$groupRow.show = value;\n            });\n            if (showGroupGetter.assign) {\n                // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n                $scope.$watch<boolean>('$groupRow.show', function (value) {\n                    showGroupGetter.assign($scope.$parent, value);\n                });\n            }\n        } else {\n            $scope.$watch<boolean>('params.hasGroup()', function (newValue) {\n                $scope.$groupRow.show = newValue;\n            });\n        }\n    }\n\n    function getVisibleColumns() {\n        return ($scope.$columns || []).filter(function (c) {\n            return c.show($scope);\n        });\n    }\n\n    function hasVisibleFilterColumn() {\n        if (!$scope.$columns) return false;\n\n        return some($scope.$columns, function ($column) {\n            return $column.show($scope) && !!$column.filter($scope);\n        });\n    }\n\n    function some<T>(array: T[], predicate: (item: T) => boolean) {\n        var found = false;\n        for (var i = 0; i < array.length; i++) {\n            var obj = array[i];\n            if (predicate(obj)) {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    }\n\n    function commonInit() {\n        ngTableEventsChannel.onAfterReloadData<T>(\n            (params, newDatapage) => {\n                var visibleColumns = getVisibleColumns();\n                if (params.hasGroup()) {\n                    $scope.$groups = (newDatapage || []) as GroupedDataResults<T>;\n                    $scope.$groups.visibleColumnCount = visibleColumns.length;\n                } else {\n                    $scope.$data = (newDatapage || []) as DataResults<T>;\n                    $scope.$data.visibleColumnCount = visibleColumns.length;\n                }\n            },\n            $scope,\n            (publisher) => $scope.params === publisher\n        );\n\n        ngTableEventsChannel.onPagesChanged<T>(\n            (params, newPages) => {\n                $scope.pages = newPages;\n            },\n            $scope,\n            (publisher) => $scope.params === publisher\n        );\n    }\n\n    commonInit();\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IAugmentedJQuery, IDirective, IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { IColumnDef, IDynamicTableColDef, ITableController, ITableInputAttributes } from './public-interfaces';\n\ninterface IScopeExtensions {\n    $columns: IColumnDef[]\n}\n\nngTableDynamic.$inject = [];\n\n/**\n * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n * definitions to render\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table-dynamic=\"$ctrl.tableParams with $ctrl.cols\" class=\"table\">\n *  <tr ng-repeat=\"row in $data\">\n *    <td ng-repeat=\"col in $columns\">{{row[col.field]}}</td>\n *  </tr>\n * </table>\n * ```\n */\nexport function ngTableDynamic () : IDirective{\n\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function(tElement: IAugmentedJQuery) {\n            var row: IAugmentedJQuery;\n\n            // IE 8 fix :not(.ng-table-group) selector\n            ng1.forEach(tElement.find('tr'), function(tr) {\n                tr = ng1.element(tr);\n                if (!tr.hasClass('ng-table-group') && !row) {\n                    row = tr;\n                }\n            });\n            if (!row) {\n                return undefined;\n            }\n\n            ng1.forEach(row.find('td'), function(item) {\n                var el = ng1.element(item);\n                var getAttrValue = function(attr: string){\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n\n                // this used in responsive table\n                var titleExpr = getAttrValue('title');\n                if (!titleExpr){\n                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                }\n                var showExpr = el.attr('ng-if');\n                if (!showExpr){\n                    el.attr('ng-if', '$columns[$index].show(this)');\n                }\n            });\n            return function (scope: IScope & IScopeExtensions, element: IAugmentedJQuery, attrs: ITableInputAttributes, controller: ITableController) {\n                var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\n                controller.setupBindingsToInternalScope(expr.tableParams);\n                controller.compileDirectiveTemplates();\n\n                scope.$watchCollection<IDynamicTableColDef[]>(expr.columns, function (newCols/*, oldCols*/) {\n                    scope.$columns = controller.buildColumns(newCols);\n                    controller.loadFilterData(scope.$columns);\n                });\n            };\n        }\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableDynamic.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IFilterConfig, IFilterConfigValues, IFilterTemplateDef } from './public-interfaces';\n\nngTableFilterConfigProvider.$inject = [];\n\n/**\n * The angular provider used to configure the behaviour of the `ngTableFilterConfig` service.\n * \n * Implements the {@link IFilterConfigProvider IFilterConfigProvider} interface\n */\nexport function ngTableFilterConfigProvider() {\n    var config: IFilterConfigValues;\n    var defaultConfig: IFilterConfigValues = {\n        defaultBaseUrl: 'ng-table/filters/',\n        defaultExt: '.html',\n        aliasUrls: {}\n    };\n\n    this.$get = ngTableFilterConfig;\n    this.resetConfigs = resetConfigs;\n    this.setConfig = setConfig;\n\n    init();\n\n    /////////\n\n    function init(){\n        resetConfigs();\n    }\n\n    function resetConfigs(){\n        config = defaultConfig;\n    }\n\n    function setConfig(customConfig: IFilterConfigValues){\n        var mergeConfig = ng1.extend({}, config, customConfig);\n        mergeConfig.aliasUrls = ng1.extend({}, config.aliasUrls, customConfig.aliasUrls);\n        config = mergeConfig;\n    }\n\n    /////////\n\n    ngTableFilterConfig.$inject = [];\n\n    function ngTableFilterConfig(): IFilterConfig {\n\n        var publicConfig: IFilterConfigValues;\n\n        var service = {\n            config: publicConfig,\n            getTemplateUrl: getTemplateUrl,\n            getUrlForAlias: getUrlForAlias\n        };\n        Object.defineProperty(service, \"config\", {\n            get: function(){\n                return publicConfig = publicConfig || ng1.copy(config);\n            },\n            enumerable: true\n        });\n\n        return service;\n\n        /////////\n\n        function getTemplateUrl(filterDef: string | IFilterTemplateDef, filterKey?: string){\n            var filterName: string;\n            if (typeof filterDef !== 'string'){\n                filterName = filterDef.id;\n            } else {\n                filterName = filterDef;\n            }\n            if (filterName.indexOf('/') !== -1){\n                return filterName;\n            }\n\n            return service.getUrlForAlias(filterName, filterKey);\n        }\n\n        function getUrlForAlias(aliasName: string, filterKey?: string){\n            return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n        }\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableFilterConfig.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nvar templateUrl = require('./filterRow.html');\n\nngTableFilterRow.$inject = [];\n\n/**\n * directive that renders the filter header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-filter-row></ng-table-filter-row>\n * ```\n */\nexport function ngTableFilterRow(){\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableFilterRowController'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableFilterRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IScope } from 'angular';\nimport { IFilterConfig, IFilterTemplateDef, IFilterTemplateDefMap } from './public-interfaces';\n\n/**\n * @private\n */\nexport interface IScopeExtensions {\n    config: IFilterConfig;\n    getFilterCellCss(filter: IFilterTemplateDefMap, layout: string): string;\n    getFilterPlaceholderValue(filterDef: string | IFilterTemplateDef, filterKey?: string): string;\n}\n\nngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n\n/**\n * Controller for the {@link ngTableFilterRow ngTableFilterRow} directive\n */\nexport function ngTableFilterRowController($scope: IScope & IScopeExtensions, ngTableFilterConfig: IFilterConfig){\n\n    $scope.config = ngTableFilterConfig;\n\n    $scope.getFilterCellCss = function (filter: IFilterTemplateDefMap, layout: string) {\n        if (layout !== 'horizontal') {\n            return 's12';\n        }\n\n        var size = Object.keys(filter).length;\n        var width = parseInt((12 / size).toString(), 10);\n        return 's' + width;\n    };\n\n    $scope.getFilterPlaceholderValue = function(filterDef: string | IFilterTemplateDef, filterKey?: string){\n        if (typeof filterDef === 'string') {\n            return '';\n        } else {\n            return filterDef.placeholder;\n        }\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableFilterRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nvar templateUrl = require('./groupRow.html');\n\nngTableGroupRow.$inject = [];\n\n/**\n * directive that renders the group header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-group-row></ng-table-group-row>\n * ```\n */\nexport function ngTableGroupRow(){\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableGroupRowController',\n        controllerAs: 'dctrl'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableGroupRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IPromise } from 'angular';\nimport { DataResult, IGroupingFunc, Grouping } from '../core';\nimport { IColumnDef } from './public-interfaces';\nimport { ITableScope } from './ngTableController';\n\n/**\n * @private\n */\nexport interface IScopeExtensions<T> {\n    $selGroup: IGroupingFunc<any> | string;\n    $selGroupTitle: string;\n    getGroupables(): Array<IGroupingFunc<any> | IColumnDef>\n    getGroupTitle(group: IGroupingFunc<any> | IColumnDef): string;\n    getVisibleColumns(): IColumnDef[];\n    groupBy(group: IGroupingFunc<any> | IColumnDef): void;\n    isSelectedGroup(group: IGroupingFunc<any> | IColumnDef): boolean;\n    toggleDetail(): IPromise<Array<DataResult<T>>>\n}\n\nngTableGroupRowController.$inject = ['$scope'];\n\n/**\n * Controller for the {@link ngTableGroupRow ngTableGroupRow} directive\n */\nexport function ngTableGroupRowController<T>($scope: ITableScope<T> & IScopeExtensions<T>){\n\n    var groupFns: Array<IGroupingFunc<any> | IColumnDef> = [];\n\n    init();\n\n    function init(){\n        $scope.getGroupables = getGroupables;\n        $scope.getGroupTitle = getGroupTitle;\n        $scope.getVisibleColumns = getVisibleColumns;\n        $scope.groupBy = groupBy;\n        $scope.isSelectedGroup = isSelectedGroup;\n        $scope.toggleDetail = toggleDetail;\n\n        $scope.$watch('params.group()', setGroup, true);\n    }\n\n    function changeSortDirection(){\n        var newDirection: string;\n        if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n            newDirection = 'desc';\n        } else if ($scope.params.hasGroup($scope.$selGroup, 'desc')){\n            newDirection = '';\n        } else {\n            newDirection = 'asc';\n        }\n        $scope.params.group($scope.$selGroup, newDirection);\n    }\n\n    function findGroupColumn(groupKey: IGroupingFunc<any> | string) {\n        return $scope.$columns.filter(function ($column) {\n            return $column.groupable($scope) === groupKey;\n        })[0];\n    }\n\n    function getGroupTitle(group: IGroupingFunc<any> | IColumnDef){\n        return isGroupingFunc(group) ? group.title : group.title($scope);\n    }\n\n    function getGroupables(){\n        var groupableCols = $scope.$columns.filter(function ($column) {\n            return !!$column.groupable($scope);\n        });\n        return groupFns.concat(groupableCols);\n    }\n\n    function getVisibleColumns(){\n        return $scope.$columns.filter(function($column){\n            return $column.show($scope);\n        })\n    }\n\n    function groupBy(group: IGroupingFunc<any> | IColumnDef){\n        if (isSelectedGroup(group)){\n            changeSortDirection();\n        } else {\n            if (isGroupingFunc(group)){\n                $scope.params.group(group);\n            } else{\n                // it's OK, we know that groupable will return a string\n                // this is guaranteed by getGroupables returning only\n                // columns that return (truthy) strings\n                $scope.params.group(group.groupable($scope) as string);\n            }\n        }\n    }\n\n    function isGroupingFunc(val: IColumnDef | Grouping<any>): val is IGroupingFunc<any> {\n        return typeof val === 'function';\n    }\n\n    function isSelectedGroup(group: IGroupingFunc<any> | IColumnDef){\n        if (isGroupingFunc(group)){\n            return group === $scope.$selGroup;\n        } else {\n            return group.groupable($scope) === $scope.$selGroup;\n        }\n    }\n\n    function setGroup(grouping: Grouping<any>){\n        var existingGroupCol = findGroupColumn($scope.$selGroup);\n        if (existingGroupCol && existingGroupCol.show.assign){\n            existingGroupCol.show.assign($scope, true);\n        }\n        if (isGroupingFunc(grouping)) {\n            groupFns = [grouping];\n            $scope.$selGroup = grouping;\n            $scope.$selGroupTitle = grouping.title;\n        } else {\n            // note: currently only one group is implemented\n            var groupKey = Object.keys(grouping || {})[0];\n            var groupedColumn = findGroupColumn(groupKey);\n            if (groupedColumn) {\n                $scope.$selGroupTitle = groupedColumn.title($scope);\n                $scope.$selGroup = groupKey;\n                if (groupedColumn.show.assign) {\n                    groupedColumn.show.assign($scope, false);\n                }\n            }\n        }\n    }\n\n    function toggleDetail(){\n        $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n        return $scope.params.reload();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableGroupRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IEventsChannel, IPageButton } from '../core'\nimport { ITableScope } from './ngTableController';\n\ninterface IScopeExtensions {\n    pages: IPageButton[]\n}\n\nngTablePagination.$inject = ['$compile', '$document', 'ngTableEventsChannel'];\n\n/**\n * Directive that renders the table pagination controls\n * @ngdoc directive\n */\nexport function ngTablePagination<T>($compile: ng1.ICompileService, $document: ng1.IDocumentService, ngTableEventsChannel: IEventsChannel): ng1.IDirective {\n\n    return {\n        restrict: 'A',\n        scope: {\n            'params': '=ngTablePagination',\n            'templateUrl': '='\n        },\n        replace: false,\n        link: function(scope: ITableScope<T> & IScopeExtensions, element: ng1.IAugmentedJQuery/*, attrs*/) {\n\n            ngTableEventsChannel.onAfterReloadData<T>(function(pubParams) {\n                scope.pages = pubParams.generatePagesArray();\n            }, scope, function(pubParams){\n                return pubParams === scope.params;\n            });\n\n            scope.$watch<string>('templateUrl', function(templateUrl) {\n                if (templateUrl === undefined) {\n                    return;\n                }\n                var template = ng1.element('<div ng-include=\"templateUrl\"></div>', $document);\n                element.append(template);\n                $compile(template)(scope);\n            });\n        }\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTablePagination.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IColumnDef, SelectData, ISelectDataFunc, ISelectOption } from './public-interfaces';\n\ninterface IInputAttributes extends ng1.IAttributes {\n    ngTableSelectFilterDs: string;\n}\n\ninterface IScopeExtensions {\n    $selectData: ISelectOption[]\n}\n\nngTableSelectFilterDs.$inject = [];\n\n/**\n * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n *\n * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n * \"deselecting\" an item from a `<select>` tag\n *\n * This directive is is focused on providing a datasource to an `ngOptions` directive\n * @ngdoc directive\n * @private\n */\nfunction ngTableSelectFilterDs(): ng1.IDirective{\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n\n    var directive = {\n        restrict: 'A',\n        controller: ngTableSelectFilterDsController\n    };\n    return directive;\n}\n\nngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\nfunction ngTableSelectFilterDsController($scope: ng1.IScope & IScopeExtensions, $parse: ng1.IParseService, $attrs: IInputAttributes, $q: ng1.IQService){\n\n    var $column: IColumnDef;\n    init();\n\n    function init(){\n        $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n        $scope.$watch<SelectData>(function(){\n            return $column && $column.data;\n        }, bindDataSource);\n    }\n\n    function bindDataSource(){\n        getSelectListData($column).then(function(data){\n            if (data && !hasEmptyOption(data)){\n                data.unshift({ id: '', title: ''});\n            }\n            data = data || [];\n            $scope.$selectData = data;\n        });\n    }\n\n    function hasEmptyOption(data: ISelectOption[]) {\n        var isMatch: boolean;\n        for (var i = 0; i < data.length; i++) {\n            var item = data[i];\n            if (item && item.id === '') {\n                isMatch = true;\n                break;\n            }\n        }\n        return isMatch;\n    }\n\n    function getSelectListData($column: IColumnDef) {\n        var dataInput = $column.data;\n        if (dataInput instanceof Array) {\n            return $q.when(dataInput);\n        } else {\n            return $q.when(dataInput && dataInput());\n        }\n    }\n}\n\nexport { ngTableSelectFilterDs };\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableSelectFilterDs.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nvar templateUrl = require('./sorterRow.html');\n\nngTableSorterRow.$inject = [];\n\n/**\n * directive that renders the sorting header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-sorter-row></ng-table-sorter-row>\n * ```\n */\nexport function ngTableSorterRow(){\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableSorterRowController'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableSorterRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\nimport { IAngularEvent } from 'angular';\nimport { ISortingValues } from '../core';\nimport { IColumnDef } from './public-interfaces';\nimport { ITableScope } from './ngTableController';\n\n/**\n * @private\n */\nexport interface IScopeExtensions {\n    sortBy($column: IColumnDef, event: IAugmentedMouseEvent): void;\n}\n\n/**\n * @private\n */\nexport interface IAugmentedMouseEvent extends IAngularEvent {\n    ctrlKey: boolean;\n    metaKey: boolean;\n}\n\nngTableSorterRowController.$inject = ['$scope'];\n\n/**\n * Controller for the {@link ngTableSorterRow ngTableSorterRow} directive\n */\nexport function ngTableSorterRowController<T>($scope: ITableScope<T> & IScopeExtensions) {\n\n    $scope.sortBy = sortBy;\n\n    ///////////\n\n    function sortBy($column: IColumnDef, event: IAugmentedMouseEvent) {\n        var parsedSortable = $column.sortable && $column.sortable();\n        if (!parsedSortable || typeof parsedSortable !== 'string') {\n            return;\n        } else {\n            var defaultSort = $scope.params.settings().defaultSort;\n            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n            var sortingParams: ISortingValues = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n            $scope.params.parameters({\n                sorting: sortingParams\n            });\n        }\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ngTableSorterRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IDefaultGetDataProvider, IDefaultGetData, IFilterFunc, INgTableParams } from './public-interfaces';\n\n/**\n * Allows for the configuration of the ngTableDefaultGetData service.\n *\n * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n * `NgTableParams.filter()` to restrict an array of data.\n *\n * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n * `NgTableParams.orderBy()` to sort an array of data.\n *\n * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n * filters respectively\n * \n * @ngdoc provider\n */\nexport class ngTableDefaultGetDataProvider implements IDefaultGetDataProvider {\n    filterFilterName = 'filter';\n    sortingFilterName = 'orderBy';\n    $get: ($filter: ng1.IFilterService) => IDefaultGetData<any>;\n    constructor() {\n        var provider = this;\n        this.$get = ngTableDefaultGetData;\n\n        ngTableDefaultGetData.$inject = ['$filter'];\n\n        /**\n         * Implementation of the {@link IDefaultGetData IDefaultGetData} interface\n         * \n         * @ngdoc service\n         */\n        function ngTableDefaultGetData<T>($filter: ng1.IFilterService): IDefaultGetData<T> {\n\n            var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n\n            (getData as IDefaultGetData<T>).applyPaging = applyPaging;\n            (getData as IDefaultGetData<T>).getFilterFn = getFilterFn;\n            (getData as IDefaultGetData<T>).getOrderByFn = getOrderByFn;\n\n            return getData as IDefaultGetData<T>;\n\n            function getFilterFn(params: INgTableParams<T>): IFilterFunc<T> {\n                var filterOptions = params.settings().filterOptions;\n                if (ng1.isFunction(filterOptions.filterFn)) {\n                    return filterOptions.filterFn;\n                } else {\n                    return $filter<ng1.IFilterFilter>(filterOptions.filterFilterName || provider.filterFilterName);\n                }\n            }\n\n            function getOrderByFn(params: INgTableParams<T>) {\n                return $filter<ng1.IFilterOrderBy>(provider.sortingFilterName);\n            }\n\n            function applyFilter(data: T[], params: INgTableParams<T>): T[] {\n                if (!params.hasFilter()) {\n                    return data;\n                }\n\n                var filter = params.filter(true);\n                var filterKeys = Object.keys(filter);\n                var parsedFilter = filterKeys.reduce(function (result, key) {\n                    result = setPath(result, filter[key], key);\n                    return result;\n                }, {});\n                var filterFn = getFilterFn(params);\n                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n            }\n\n            function applyPaging(data: T[], params: INgTableParams<T>): T[] {\n                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n                params.total(data.length); // set total for recalc pagination\n                return pagedData;\n            }\n\n            function applySort(data: T[], params: INgTableParams<T>): T[] {\n                var orderBy = params.orderBy();\n                var orderByFn = getOrderByFn(params);\n                return orderBy.length ? orderByFn(data, orderBy) : data;\n            }\n\n            function getData(data: T[], params: INgTableParams<T>): T[] {\n                if (data == null) {\n                    return [];\n                }\n\n                var options = ng1.extend({}, defaultDataOptions, params.settings().dataOptions);\n\n                var fData = options.applyFilter ? applyFilter(data, params) : data;\n                var orderedData = options.applySort ? applySort(fData, params) : fData;\n                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n            }\n\n            // Sets the value at any depth in a nested object based on the path\n            // note: adapted from: underscore-contrib#setPath\n            function setPath(obj: any, value: any, path: string) {\n                var keys = path.split('.');\n                var ret = obj;\n                var lastKey = keys[keys.length - 1];\n                var target = ret;\n\n                var parentPathKeys = keys.slice(0, keys.length - 1);\n                parentPathKeys.forEach(function (key) {\n                    if (!target.hasOwnProperty(key)) {\n                        target[key] = {};\n                    }\n                    target = target[key];\n                });\n\n                target[lastKey] = value;\n                return ret;\n            }\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/ngTableDefaultGetData.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IDefaults } from './public-interfaces';\n\n/**\n * Default values for ngTable\n * @ngdoc object\n */\nexport var ngTableDefaults : IDefaults = {\n    params: {},\n    settings: {}\n};\n\n\n// WEBPACK FOOTER //\n// ./src/core/ngTableDefaults.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IEventsChannel, InternalTableParams, INgTableParams } from './public-interfaces';\n\nngTableEventsChannel.$inject = ['$rootScope'];\n\n/**\n * Implementation of the {@link IEventsChannel IEventsChannel} interface\n * @ngdoc service\n */\nexport function ngTableEventsChannel($rootScope: ng1.IRootScopeService): IEventsChannel {\n\n    var events = {};\n    events = addTableParamsEvent('afterCreated', events);\n    events = addTableParamsEvent('afterReloadData', events);\n    events = addTableParamsEvent('datasetChanged', events);\n    events = addTableParamsEvent('pagesChanged', events);\n    return events as IEventsChannel;\n\n    //////////\n\n    function addTableParamsEvent(eventName: string, target: {}){\n        var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n        var event = {\n            ['on' + fnName]: createEventSubscriptionFn(eventName),\n            ['publish' + fnName]: createPublishEventFn(eventName)\n        };\n        return ng1.extend(target, event);\n    }\n\n    type EventSelector = INgTableParams<any>|((publisher: INgTableParams<any>) => boolean);\n\n    function createEventSubscriptionFn(eventName: string){\n        \n        return function subscription(\n            handler: (...args: any[]) => void, \n            eventSelectorOrScope: EventSelector|ng1.IScope, \n            eventSelector?: EventSelector) {\n\n            var actualEvtSelector: (publisher: INgTableParams<any>) => boolean;\n            var scope: ng1.IScope = $rootScope;\n\n            if (isScopeLike(eventSelectorOrScope)) {\n                scope = eventSelectorOrScope;\n                actualEvtSelector = createEventSelectorFn(eventSelector);\n            } else {\n                actualEvtSelector = createEventSelectorFn(eventSelectorOrScope);\n            }\n\n            return scope.$on('ngTable:' + eventName, function(event: ng1.IAngularEvent, params: InternalTableParams<any>, ...eventArgs: any[]){\n                // don't send events published by the internal NgTableParams created by ngTableController\n                if (params.isNullInstance) return;\n\n                var fnArgs = [params].concat(eventArgs);\n                if (actualEvtSelector.apply(this, fnArgs)){\n                    handler.apply(this, fnArgs);\n                }\n            });\n        }\n\n        function createEventSelectorFn(eventSelector: EventSelector): (publisher: INgTableParams<any>) => boolean {\n            if (!eventSelector) {\n                return (publisher: INgTableParams<any>) => true;\n            } else if (isEventSelectorFunc(eventSelector)) {\n                return eventSelector\n            } else {\n                // shorthand for subscriber to only receive events from a specific publisher instance\n                return (publisher: INgTableParams<any>) => publisher === eventSelector;\n            }\n        }\n\n        function isEventSelectorFunc(val: EventSelector): val is (publisher: INgTableParams<any>) => boolean {\n            return typeof val === 'function';\n        }\n\n        function isScopeLike(val: any): val is ng1.IScope {\n            return val && typeof val.$new === 'function';\n        }\n    }\n\n    function createPublishEventFn(eventName: string){\n        return function publish(...args: any[]){\n            $rootScope.$broadcast('ngTable:' + eventName, ...args);\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/ngTableEventsChannel.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { \n    IDataRowGroup, IDefaults, IDefaultGetData, IEventsChannel, IFilterSettings, IFilterValues, IGetDataFunc, Grouping, \n    IGroupValues, IGroupingFunc, IGroupSettings, IPageButton, IParamValues, ISettings, ISortingValues, INgTableParams, \n    ITableParamsConstructor } from './public-interfaces'\n\nngTableParamsFactory.$inject = [\n    '$q', '$log', '$filter', 'ngTableDefaults', 'ngTableDefaultGetData', 'ngTableEventsChannel'\n];\n\n/**\n * Implmenentation of the {@link INgTableParams INgTableParams} interface\n * @ngdoc service\n */\nexport function ngTableParamsFactory<T>(\n    $q: ng1.IQService, $log: ng1.ILogService, $filter: ng1.IFilterService, ngTableDefaults: IDefaults, \n    ngTableDefaultGetData: IDefaultGetData<any>, ngTableEventsChannel: IEventsChannel) {\n\n    return NgTableParams;\n    \n\n    function NgTableParams<T>(baseParameters: IParamValues<T> | boolean, baseSettings: ISettings<T>): INgTableParams<T> {\n\n        type Memento = {\n            params: IParamValues<T>;\n            groupSortDirection?: string;\n        };\n\n        function isNumber(n: any) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        }\n\n        // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n        // is one of these\n        if (typeof baseParameters === \"boolean\"){\n            this.isNullInstance = true;\n        }\n\n        var self: INgTableParams<T> = this,\n            prevParamsMemento: Memento,\n            errParamsMemento: Memento,\n            isCommittedDataset = false,\n            initialEvents: Function[] = [],\n            log = function(...args: any[]) {\n                if (_settings.debugMode && $log.debug) {\n                    $log.debug(...args);\n                }\n            },\n            defaultFilterOptions: IFilterSettings<T> = {\n                filterComparator: undefined, // look for a substring match in case insensitive way\n                filterDelay: 500,\n                filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n                filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n                filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n                filterLayout: 'stack' // alternative: 'horizontal'\n            },\n            defaultGroupOptions: IGroupSettings = {\n                defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n                isExpanded: true\n            },\n            defaultSettingsFns = getDefaultSettingFns();\n\n        this.data = [];\n\n        this.parameters = function(newParameters?: IParamValues<T>| { [name: string]: string }, parseParamsFromUrl?: boolean) {\n            parseParamsFromUrl = parseParamsFromUrl || false;\n            if (typeof newParameters !== undefined) {\n                for (var key in newParameters) {\n                    var value = newParameters[key];\n                    if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                        var keys = key.split(/\\[(.*)\\]/).reverse()\n                        var lastKey = '';\n                        for (var i = 0, len = keys.length; i < len; i++) {\n                            var name = keys[i];\n                            if (name !== '') {\n                                var v = value;\n                                value = {};\n                                value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                            }\n                        }\n                        if (lastKey === 'sorting') {\n                            _params[lastKey] = {};\n                        }\n                        _params[lastKey] = ng1.extend(_params[lastKey] || {}, value[lastKey]);\n                    } else {\n                        if (key === 'group'){\n                            _params[key] = parseGroup(newParameters[key]);\n                        } else {\n                            _params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                        }\n                    }\n                }\n                log('ngTable: set parameters', _params);\n                return this;\n            }\n            return _params;\n        };\n\n        function parseGroup(group: string | Grouping<T>){\n            var defaultSort = _settings.groupOptions && _settings.groupOptions.defaultSort;\n            if (!group) {\n                return group;\n            } else if (isGroupingFun(group)) {\n                if (group.sortDirection == null){\n                    group.sortDirection = defaultSort;\n                }\n                return group;\n            } else if (typeof group === 'object') {\n                for (var key in group) {\n                    if (group[key] == null){\n                        group[key] = defaultSort;\n                    }\n                }\n                return group;\n            } else {\n                return {\n                    [group]: defaultSort\n                };\n            }\n        }\n\n        /**\n         * @ngdoc method\n         * @name NgTableParams#settings\n         * @description Set new settings for table\n         *\n         * @param {string} newSettings New settings or undefined\n         * @returns {Object} Current settings or `this`\n         */\n        this.settings = function(newSettings?: ISettings<T>) {\n            if (ng1.isDefined(newSettings)) {\n\n                // todo: don't modify newSettings object: this introduces unexpected side effects;\n                // instead take a copy of newSettings\n\n                if (newSettings.filterOptions){\n                    newSettings.filterOptions = ng1.extend({}, _settings.filterOptions, newSettings.filterOptions);\n                }\n                if (newSettings.groupOptions){\n                    newSettings.groupOptions = ng1.extend({}, _settings.groupOptions, newSettings.groupOptions);\n                }\n\n                if (ng1.isArray(newSettings.dataset)) {\n                    //auto-set the total from passed in dataset\n                    newSettings.total = newSettings.dataset.length;\n                }\n\n                var originalDataset = _settings.dataset;\n                _settings = ng1.extend(_settings, newSettings);\n\n                if (ng1.isArray(newSettings.dataset)) {\n                    optimizeFilterDelay();\n                }\n\n                // note: using != as want null and undefined to be treated the same\n                var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n                if (hasDatasetChanged) {\n                    if (isCommittedDataset){\n                        this.page(1); // reset page as a new dataset has been supplied\n                    }\n                    isCommittedDataset = false;\n\n                    var fireEvent = function () {\n                        ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n                    };\n\n                    if (initialEvents){\n                        initialEvents.push(fireEvent);\n                    } else {\n                        fireEvent();\n                    }\n                }\n                log('ngTable: set settings', _settings);\n                return this;\n            }\n            return _settings;\n        };\n\n        this.page = function(page?: number) {\n            return page !== undefined ? this.parameters({\n                'page': page\n            }) : _params.page;\n        };\n\n        this.total = function(total?: number) {\n            return total !== undefined ? this.settings({\n                'total': total\n            }) : _settings.total;\n        };\n\n        this.count = function(count?: number) {\n            // reset to first page because can be blank page\n            return count !== undefined ? this.parameters({\n                'count': count,\n                'page': 1\n            }) : _params.count;\n        };\n\n        this.filter = function(filter?: IFilterValues | boolean) {\n            if (filter != null && typeof filter === 'object') {\n                return this.parameters({\n                    'filter': filter,\n                    'page': 1\n                });\n            } else if (filter === true){\n                var keys = Object.keys(_params.filter);\n                var significantFilter: IFilterValues = {};\n                for (var i=0; i < keys.length; i++){\n                    var filterValue = _params.filter[keys[i]];\n                    if (filterValue != null && filterValue !== '') {\n                        significantFilter[keys[i]] = filterValue;\n                    }\n                }\n                return significantFilter;\n            } else {\n                return _params.filter;\n            }\n        };\n\n        this.group = function(group?: Grouping<T> | string, sortDirection?: string) {\n            if (group === undefined){\n                return _params.group;\n            }\n\n            var newParameters: IParamValues<T> = {\n                page: 1\n            };\n            if (isGroupingFun(group) && sortDirection !== undefined){\n                group.sortDirection = sortDirection;\n                newParameters.group = group;\n            } else if (typeof group === 'string' && sortDirection !== undefined) {\n                newParameters.group = { [group]: sortDirection };\n            } else {\n                newParameters.group = group;\n            }\n            this.parameters(newParameters);\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name NgTableParams#sorting\n         * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n         *\n         * @param {string} sorting New sorting\n         * @returns {Object} Current sorting or `this`\n         */\n        this.sorting = function(sorting?: ISortingValues | string, direction?: string) {\n            if (typeof sorting === 'string' && direction !== undefined) {\n                this.parameters({\n                    'sorting': { [sorting]: direction }\n                });\n                return this;\n            }\n            return sorting !== undefined ? this.parameters({\n                'sorting': sorting\n            }) : _params.sorting;\n        };\n\n        this.isSortBy = function(field: string, direction?: string) {\n            if(direction !== undefined) {\n                return _params.sorting[field] !== undefined && _params.sorting[field] == direction;\n            } else {\n                return _params.sorting[field] !== undefined;\n            }\n        };\n\n        /**\n         * @ngdoc method\n         * @name NgTableParams#orderBy\n         * @description Return object of sorting parameters for angular filter\n         *\n         * @returns {Array} Array like: [ '-name', '+age' ]\n         */\n        this.orderBy = function() {\n            return convertSortToOrderBy(_params.sorting);\n        };\n\n        function convertSortToOrderBy(sorting: ISortingValues){\n            var result: string[] = [];\n            for (var column in sorting) {\n                result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n            }\n            return result;\n        }\n\n        /**\n         * @ngdoc method\n         * @name NgTableParams#generatePagesArray\n         * @description Generate array of pages\n         *\n         * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n         *\n         * @param {boolean} currentPage which page must be active\n         * @param {boolean} totalItems  Total quantity of items\n         * @param {boolean} pageSize    Quantity of items on page\n         * @param {number} maxBlocks    Quantity of blocks for pagination\n         * @returns {Array} Array of pages\n         */\n        this.generatePagesArray = function(currentPage?: number, totalItems?: number, pageSize?: number, maxBlocks?: number) {\n            if (!arguments.length){\n                currentPage = this.page();\n                totalItems = this.total();\n                pageSize = this.count();\n            }\n\n            var maxPage: number, maxPivotPages: number, minPage: number, numPages: number;\n            maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\n            var pages: IPageButton[] = [];\n            numPages = Math.ceil(totalItems / pageSize);\n            if (numPages > 1) {\n                pages.push({\n                    type: 'prev',\n                    number: Math.max(1, currentPage - 1),\n                    active: currentPage > 1\n                });\n                pages.push({\n                    type: 'first',\n                    number: 1,\n                    active: currentPage > 1,\n                    current: currentPage === 1\n                });\n                maxPivotPages = Math.round((_settings.paginationMaxBlocks - _settings.paginationMinBlocks) / 2);\n                minPage = Math.max(2, currentPage - maxPivotPages);\n                maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n                minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n                var i = minPage;\n                while (i <= maxPage) {\n                    if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                        pages.push({\n                            type: 'more',\n                            active: false\n                        });\n                    } else {\n                        pages.push({\n                            type: 'page',\n                            number: i,\n                            active: currentPage !== i,\n                            current: currentPage === i\n                        });\n                    }\n                    i++;\n                }\n                pages.push({\n                    type: 'last',\n                    number: numPages,\n                    active: currentPage !== numPages,\n                    current: currentPage === numPages\n                });\n                pages.push({\n                    type: 'next',\n                    number: Math.min(numPages, currentPage + 1),\n                    active: currentPage < numPages\n                });\n            }\n            return pages;\n        };\n\n        /**\n         * @ngdoc method\n         * @name NgTableParams#isDataReloadRequired\n         * @description Return true when a change to this `NgTableParams` instance should require the reload method\n         * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n         *\n         * Note that this method will return false when the reload method has run but fails. In this case\n         * `hasErrorState` will return true.\n         */\n        this.isDataReloadRequired = function(){\n            // note: using != as want to treat null and undefined the same\n            return !isCommittedDataset || !ng1.equals(createComparableParams(), prevParamsMemento)\n                || hasGlobalSearchFieldChanges();\n        };\n\n        function createComparableParams(): Memento {\n            var group = _params.group;\n            return {\n                params: _params,\n                groupSortDirection: isGroupingFun(group) ? group.sortDirection : undefined\n            };\n        }\n        function isGroupingFun(val: string | Grouping<T>): val is IGroupingFunc<T> {\n                return typeof val === 'function'\n        }\n        /**\n         * @ngdoc method\n         * @name NgTableParams#hasFilter\n         * @description Determines if NgTableParams#filter has significant filter value(s)\n         * (any value except null, undefined, or empty string)\n         * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n         */\n        this.hasFilter = function(){\n            return Object.keys(this.filter(true)).length > 0;\n        };\n\n        this.hasGroup = function(group?: IGroupingFunc<T> | string, sortDirection?: string){\n            if (group == null) {\n                return isGroupingFun(_params.group) || Object.keys(_params.group).length > 0\n            }\n\n            if (isGroupingFun(group)) {\n                if (sortDirection == null) {\n                    return _params.group === group;\n                } else {\n                    return _params.group === group && group.sortDirection === sortDirection;\n                }\n            } else {\n                if (sortDirection == null) {\n                    return Object.keys(_params.group).indexOf(group) !== -1;\n                } else {\n                    return( _params.group as IGroupValues)[group] === sortDirection;\n                }\n            }\n        };\n\n        this.hasFilterChanges = function(){\n            var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);\n            return !ng1.equals((_params.filter), previousFilter) || hasGlobalSearchFieldChanges();\n        };\n\n        function hasGlobalSearchFieldChanges(){\n            var currentVal = (_params.filter && _params.filter['$']);\n            var previousVal =\n                (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter['$']);\n            return !ng1.equals(currentVal, previousVal);\n        }\n\n        this.url = function(asString?: boolean) {\n            // this function is an example of Typescript gone bad!!\n            asString = asString || false;\n            var pairs: any[] | { [name: string]: string } = (asString ? [] : {});\n            for (var key in _params) {\n                if (_params.hasOwnProperty(key)) {\n                    var item = (_params as { [name: string]: any })[key],\n                        name = encodeURIComponent(key);\n                    if (typeof item === \"object\") {\n                        for (var subkey in item) {\n                            if (isSignificantValue(item[subkey], key)) {\n                                var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                                collectValue(item[subkey], pname);\n                            }\n                        }\n                    } else if (!ng1.isFunction(item) && isSignificantValue(item, key)) {\n                        collectValue(item, name);\n                    }\n                }\n            }\n            return pairs;\n\n            function collectValue(value: any, key: string){\n                if (isArray(pairs)) {\n                    pairs.push(key + \"=\" + encodeURIComponent(value));\n                } else {\n                    pairs[key] = encodeURIComponent(value);\n                }\n            }\n\n            function isArray(pairs: any[] | {}): pairs is Array<any> {\n                return asString;\n            }\n\n            function isSignificantValue(value: any, key: string){\n                return key === \"group\" ? true : typeof value !== undefined && value !== \"\";\n            }\n        };\n\n        this.reload = function() {\n            var self: INgTableParams<T> = this,\n                pData: ng1.IPromise<any> = null;\n\n            _settings.$loading = true;\n\n            prevParamsMemento = ng1.copy(createComparableParams());\n            isCommittedDataset = true;\n\n            if (self.hasGroup()) {\n                pData = runInterceptorPipeline($q.when(_settings.getGroups(self)));\n            } else {\n                const fn = _settings.getData as IGetDataFunc<T>;\n                pData = runInterceptorPipeline($q.when(fn(self)));\n            }\n\n            log('ngTable: reload data');\n\n            var oldData = self.data;\n            return pData.then(function(data) {\n                _settings.$loading = false;\n                errParamsMemento = null;\n\n                self.data = data;\n                // note: I think it makes sense to publish this event even when data === oldData\n                // subscribers can always set a filter to only receive the event when data !== oldData\n                ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n                self.reloadPages();\n\n                return data;\n            }).catch(function(reason){\n                errParamsMemento = prevParamsMemento;\n                // \"rethrow\"\n                return $q.reject(reason);\n            });\n        };\n\n        this.hasErrorState = function(){\n            return !!(errParamsMemento && ng1.equals(errParamsMemento, createComparableParams()));\n        };\n\n        function optimizeFilterDelay(){\n            // don't debounce by default filter input when working with small synchronous datasets\n            if (_settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&\n                _settings.total <= _settings.filterOptions.filterDelayThreshold &&\n                _settings.getData === defaultSettingsFns.getData){\n                _settings.filterOptions.filterDelay = 0;\n            }\n        }\n\n        this.reloadPages = (function() {\n            var currentPages: IPageButton[];\n            return function(){\n                var oldPages = currentPages;\n                var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n                if (!ng1.equals(oldPages, newPages)){\n                    currentPages = newPages;\n                    ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n                }\n            }\n        })();\n\n        function runInterceptorPipeline(fetchedData: ng1.IPromise<any>){\n            var interceptors = _settings.interceptors || [];\n\n            return interceptors.reduce(function(result, interceptor){\n                var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;\n                var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;\n                return result.then(function(data){\n                    return thenFn(data, self);\n                }, function(reason){\n                    return rejectFn(reason, self);\n                });\n            }, fetchedData);\n        }\n\n        function getDefaultSettingFns(){\n\n            return {\n                getData: getData,\n                getGroups: getGroups\n            };\n\n            /**\n             * @ngdoc method\n             * @name settings#getData\n             * @description Returns the data to display in the table\n             *\n             * Called by `NgTableParams` whenever it considers new data is to be loaded\n             *\n             * @param {Object} params the `NgTableParams` requesting data\n             */\n            function getData(params: INgTableParams<T>) {\n                return ngTableDefaultGetData(params.settings().dataset, params);\n            }\n\n            /**\n             * @ngdoc method\n             * @name settings#getGroups\n             * @description Return groups of data to display in the table\n             *\n             * Called by `NgTableParams` whenever it considers new data is to be loaded\n             * and when a `group` value has been assigned\n             *\n             * @param {Object} params the `NgTableParams` requesting data\n             */\n            function getGroups(params: INgTableParams<T>) {\n\n                var group = params.group();\n                var groupFn: IGroupingFunc<T>;\n                var sortDirection: string = undefined;\n                if (isGroupingFun(group)) {\n                    groupFn = group;\n                    sortDirection = group.sortDirection;\n                } else {\n                    // currently support for only one group implemented\n                    var groupField = Object.keys(group)[0];\n                    sortDirection = group[groupField];\n                    groupFn = function(item){\n                        return getPath(item, groupField);\n                    };\n                }\n\n                var settings = params.settings();\n                var originalDataOptions = settings.dataOptions;\n                settings.dataOptions = { applyPaging: false };\n                const getData: IGetDataFunc<T> = settings.getData;\n                var gotData = $q.when(getData(params));\n                return gotData.then(function(data) {\n                    var groups: { [name: string]: IDataRowGroup<T> } = {};\n                    ng1.forEach(data, function(item) {\n                        var groupName = groupFn(item);\n                        groups[groupName] = groups[groupName] || {\n                                data: [],\n                                $hideRows: !settings.groupOptions.isExpanded,\n                                value: groupName\n                            };\n                        groups[groupName].data.push(item);\n                    });\n                    var result: IDataRowGroup<T>[] = [];\n                    for (var i in groups) {\n                        result.push(groups[i]);\n                    }\n                    if (sortDirection) {\n                        var orderByFn = ngTableDefaultGetData.getOrderByFn();\n                        var orderBy = convertSortToOrderBy({\n                            value: sortDirection\n                        });\n                        result = orderByFn(result, orderBy);\n                    }\n\n                    return ngTableDefaultGetData.applyPaging(result, params);\n                }).finally(function(){\n                    // restore the real options\n                    settings.dataOptions = originalDataOptions;\n                });\n            }\n\n            function getPath (obj: { [name: string]: any}, ks: string | string[]): any {\n                // origianl source https://github.com/documentcloud/underscore-contrib\n\n                let keys: string[];\n                if (typeof ks === \"string\"){\n                    keys = ks.split(\".\");\n                } else {\n                    keys = ks;\n                }\n\n                // If we have reached an undefined property\n                // then stop executing and return undefined\n                if (obj === undefined) return void 0;\n\n                // If the path array has no more elements, we've reached\n                // the intended property and return its value\n                if (keys.length === 0) return obj;\n\n                // If we still have elements in the path array and the current\n                // value is null, stop executing and return undefined\n                if (obj === null) return void 0;\n\n                return getPath(obj[keys[0]], keys.slice(1));\n            }\n        }\n\n        var _params: IParamValues<T> = {\n            page: 1,\n            count: 10,\n            filter: {},\n            sorting: {},\n            group: {}\n        };\n        ng1.extend(_params, ngTableDefaults.params);\n\n        /**\n         * @ngdoc object\n         * @name settings\n         * @module ngTable\n         * @description configuration settings for `NgTableParams`\n         */\n        var _settings: ISettings<T> = {\n            $loading: false,\n            dataset: null, //allows data to be set when table is initialized\n            total: 0,\n            defaultSort: 'desc',\n            filterOptions: ng1.copy(defaultFilterOptions),\n            groupOptions: ng1.copy(defaultGroupOptions),\n            counts: [10, 25, 50, 100],\n            interceptors: [],\n            paginationMaxBlocks: 11,\n            paginationMinBlocks: 5,\n            sortingIndicator: 'span'\n        };\n\n        this.settings(defaultSettingsFns);\n        this.settings(ngTableDefaults.settings);\n        this.settings(baseSettings);\n        this.parameters(baseParameters, true);\n\n        ngTableEventsChannel.publishAfterCreated(this);\n        // run events during construction after the initial create event. That way a consumer\n        // can subscribe to all events for a table without \"dropping\" an event\n        ng1.forEach(initialEvents, function(event){\n            event();\n        });\n        initialEvents = null;\n\n        return this;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/ngTableParams.ts","var path = 'ng-table/filterRow.html';\nvar html = \"<tr ng-show=show_filter class=ng-table-filters> <th data-title-text=\\\"{{$column.titleAlt(this) || $column.title(this)}}\\\" ng-repeat=\\\"$column in $columns\\\" ng-if=$column.show(this) class=\\\"filter {{$column.class(this)}}\\\" ng-class=\\\"params.settings().filterOptions.filterLayout === 'horizontal' ? 'filter-horizontal' : ''\\\"> <div ng-repeat=\\\"(name, filter) in $column.filter(this)\\\" ng-include=config.getTemplateUrl(filter) class=filter-cell ng-class=\\\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? 'last' : '']\\\"> </div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filterRow.html\n// module id = 24\n// module chunks = 0","var path = 'ng-table/filters/number.html';\nvar html = \"<input type=number name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/number.html\n// module id = 25\n// module chunks = 0","var path = 'ng-table/filters/select-multiple.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $column.data\\\" ng-disabled=$filterRow.disabled multiple=multiple ng-multiple=true ng-model=params.filter()[name] class=\\\"filter filter-select-multiple form-control\\\" name={{name}}> </select> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/select-multiple.html\n// module id = 26\n// module chunks = 0","var path = 'ng-table/filters/select.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $selectData\\\" ng-table-select-filter-ds=$column ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"filter filter-select form-control\\\" name={{name}}> <option style=display:none value=\\\"\\\"></option> </select> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/select.html\n// module id = 27\n// module chunks = 0","var path = 'ng-table/filters/text.html';\nvar html = \"<input type=text name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/text.html\n// module id = 28\n// module chunks = 0","var path = 'ng-table/groupRow.html';\nvar html = \"<tr ng-if=params.hasGroup() ng-show=$groupRow.show class=ng-table-group-header> <th colspan={{getVisibleColumns().length}} class=sortable ng-class=\\\"{\\n                    'sort-asc': params.hasGroup($selGroup, 'asc'),\\n                    'sort-desc':params.hasGroup($selGroup, 'desc')\\n                  }\\\"> <a href=\\\"\\\" ng-click=\\\"isSelectorOpen = !isSelectorOpen\\\" class=ng-table-group-selector> <strong class=sort-indicator>{{$selGroupTitle}}</strong> <button class=\\\"btn btn-default btn-xs ng-table-group-close\\\" ng-click=\\\"$groupRow.show = false; $event.preventDefault(); $event.stopPropagation();\\\"> <span class=\\\"glyphicon glyphicon-remove\\\"></span> </button> <button class=\\\"btn btn-default btn-xs ng-table-group-toggle\\\" ng-click=\\\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\\\"> <span class=glyphicon ng-class=\\\"{\\n                    'glyphicon-resize-small': params.settings().groupOptions.isExpanded,\\n                    'glyphicon-resize-full': !params.settings().groupOptions.isExpanded\\n                }\\\"></span> </button> </a> <div class=list-group ng-if=isSelectorOpen> <a href=\\\"\\\" class=list-group-item ng-repeat=\\\"group in getGroupables()\\\" ng-click=groupBy(group)> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\\\"isSelectedGroup(group) && 'sort-indicator'\\\"></strong> </a> </div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/groupRow.html\n// module id = 29\n// module chunks = 0","var path = 'ng-table/header.html';\nvar html = \"<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/header.html\n// module id = 30\n// module chunks = 0","var path = 'ng-table/pager.html';\nvar html = \"<div class=\\\"ng-cloak ng-table-pager\\\" ng-if=params.data.length> <div ng-if=params.settings().counts.length class=\\\"ng-table-counts btn-group pull-right\\\"> <button ng-repeat=\\\"count in params.settings().counts\\\" type=button ng-class=\\\"{'active':params.count() == count}\\\" ng-click=params.count(count) class=\\\"btn btn-default\\\"> <span ng-bind=count></span> </button> </div> <ul ng-if=pages.length class=\\\"pagination ng-table-pagination\\\"> <li ng-class=\\\"{'disabled': !page.active && !page.current, 'active': page.current}\\\" ng-repeat=\\\"page in pages\\\" ng-switch=page.type> <a ng-switch-when=prev ng-click=params.page(page.number) href=\\\"\\\">&laquo;</a> <a ng-switch-when=first ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=page ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=more ng-click=params.page(page.number) href=\\\"\\\">&#8230;</a> <a ng-switch-when=last ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a ng-switch-when=next ng-click=params.page(page.number) href=\\\"\\\">&raquo;</a> </li> </ul> </div> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/pager.html\n// module id = 31\n// module chunks = 0","var path = 'ng-table/sorterRow.html';\nvar html = \"<tr class=ng-table-sort-header> <th title={{$column.headerTitle(this)}} ng-repeat=\\\"$column in $columns\\\" ng-class=\\\"{\\n                    'sortable': $column.sortable(this),\\n                    'sort-asc': params.sorting()[$column.sortable(this)]=='asc',\\n                    'sort-desc': params.sorting()[$column.sortable(this)]=='desc'\\n                  }\\\" ng-click=\\\"sortBy($column, $event)\\\" ng-if=$column.show(this) ng-init=\\\"template = $column.headerTemplateURL(this)\\\" class=\\\"header {{$column.class(this)}}\\\"> <div ng-if=!template class=ng-table-header ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'div'}\\\"> <span ng-bind=$column.title(this) ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'span'}\\\"></span> </div> <div ng-if=template ng-include=template></div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/sorterRow.html\n// module id = 32\n// module chunks = 0","import * as ng1 from 'angular';\nimport coreModule from './src/core';\nimport browserModule from './src/browser';\n\nconst ngTable = ng1.module('ngTable', [coreModule.name, browserModule.name]);\n\nexport { ngTable };\nexport * from './src/core';\nexport * from './src/browser';\n\n\n// WEBPACK FOOTER //\n// ./index.ts"],"sourceRoot":""}